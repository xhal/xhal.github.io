<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7.9_源码安装Openresty1.21.4.1</title>
    <url>/2022/09/333f749f.html</url>
    <content><![CDATA[# 1、环境及版本
系统版本： Centos 7.9.2009
Openresty:  1.21.4.1
# 2、必要组件安装 (执行 yum 命令安装)
yum install openssl-devel gcc curl pcre-devel -y# 3、获取安装包、解压
访问官网地址： https://openresty.org
获取下载链接： https://openresty.org/download/openresty-1.21.4.1.tar.gz
# 切换到目录cd /usr/local# wget 下载安装包wget  https://openresty.org/download/openresty-1.21.4.1.tar.gz# 解压命令tar -zxvf openresty-1.21.4.1.tar.gz# 进入解压目录cd openresty-1.21.4.1# 4、修改源码，以支持  ip_hash  可以在内网同网段生效，以实现负载均衡
[root@nginx openresty-1.21.4.1]# vim bundle/nginx-1.21.4/src/http/modules/ngx_http_upstream_ip_hash_module.c...# 修改位置一：  第 80 行，数字 3 改为 4 ngx_http_upstream_ip_hash_pseudo_addr [3] 修改为 ngx_http_upstream_ip_hash_pseudo_addr [4] 80 static u_char ngx_http_upstream_ip_hash_pseudo_addr[3];81 ...# 修改位置二：  第 124 行，数字 3 改为 4; [iphp->addrlen = 3] 修改为 [iphp->addrlen = 4] 121     case AF_INET:122         sin = (struct sockaddr_in *) r->connection->sockaddr;123         iphp->addr = (u_char *) &amp;sin->sin_addr.s_addr;124         iphp->addrlen = 3;125         break;126 127 #if (NGX_HAVE_INET6)128     case AF_INET6:129         sin6 = (struct sockaddr_in6 *) r->connection->sockaddr    ;130         iphp->addr = (u_char *) &amp;sin6->sin6_addr.s6_addr;131         iphp->addrlen = 16;132         break;133 #endif134 # 修改位置三：  第 137 行，数字 3 改为 4; [iphp->addrlen = 3] 修改为 [iphp->addrlen = 4] 135     default:136         iphp->addr = ngx_http_upstream_ip_hash_pseudo_addr;137         iphp->addrlen = 3;138     &#125;# 5、安装
# 执行 configure 命令 (默认安装目录 `--prefix=/usr/local/openresty`)# 需要的模块自定义，此处仅示例./configure --prefix=/usr/local/openresty \  --with-luajit \  --with-http_ssl_module \  --with-http_v2_module \  --with-http_realip_module # 执行安装命令makemake install# 6、 开机启动
# 方法一 (/etc/rc.local)：
[root@nginx local]# vim /etc/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/local# 启动 Openresty nginx 服务/usr/local/openresty/nginx/sbin/nginx
PS: Centos7 默认 rc.local 是不可执行的，仅是为了兼容性添加。
若重启验证不生效，则需要给此文件添加执行权限
注意：此文件执行时，  /etc/profile  配置的环境变量不会生效

[root@nginx home]# chmod +x /etc/rc.d/rc.local[root@nginx rc.d]# cd /etc/rc.d/[root@nginx rc.d]# lltotal 4drwxr-xr-x. 2 root root  70 Mar 10 15:30 init.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc0.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc1.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc2.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc3.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc4.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc5.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc6.d-rwxrwxrwx. 1 root root 550 Mar 10 17:36 rc.local[root@nginx rc.d]## 方法二（使用 service）：
在系统服务目录   /usr/lib/systemd/system/  下，创建  openresty.service  文件
[Unit]# 服务描述Description=Openresty# 在 XX 服务后启动After=network.target# 服务运行参数； 注意本节点内命令要用绝对路径[Service]# 后台运行方式Type=forking# 启动命令ExecStart=/usr/local/openresty/nginx/sbin/nginx -c /usr/local/openresty/nginx/conf/nginx.conf# 是否给服务分配独立的临时空间PrivateTmp=true# 运行级别下服务安装的相关设置， 可设置为多用户，即系统运行级别为 3[Install]WantedBy=multi-user.targetsystemctl enable openresty.service    # 设置开机启动systemctl disable openresty.service   # 停止开机启动systemctl start openresty.service     # 启动服务systemctl stop openresty.service      # 停止服务systemctl status openresty.service    # 查看服务状态systemctl restart openresty.service   # 重启服务systemctl list-units --type=service   # 查看所有已启动的服务]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.9_源码安装Redis_5.x</title>
    <url>/2022/08/4b3066d5.html</url>
    <content><![CDATA[# 1、环境及版本
系统版本： Centos 7.9.2009
Redis:  5.0.14
# 2、源码安装 cd redis-5.0.14
tar -zxvf redis-5.0.14.tar.gzcd redis-5.0.14make # 指定 安装目录 PREFIXmake PREFIX=/usr/local/redis install# 指定 安装目录 PREFIX
make PREFIX=/usr/local/redis install
# 3、复制、修改 [redis.conf] 配置
# 创建 redis 下的配置目录mkdir -p /usr/local/redis/confmkdir -p /usr/local/redis/datamkdir -p /usr/local/redis/logs# 创建完成后，目录结构[root@centos7 redis]# tree /usr/local/redis//usr/local/redis/├── bin│     ├── redis-benchmark│     ├── redis-check-aof│     ├── redis-check-rdb│     ├── redis-cli│     ├── redis-sentinel -> redis-server│     └── redis-server├── conf   # 配置文件存放目录|     └── redis.conf   # 从 源码包 复制过来的默认配置文件├── data   # rdb 数据文件存放目录├── logs   # 日志文件存放目录修改 [redis.conf] 配置
[root@centos7 redis]# vim conf/redis.conf# bind IP 配置bind 0.0.0.0# 守护进程方式运行daemonize yes# 日志文件路径（配置到上方创建的日志目录）logfile "/usr/local/redis/log/redis_6379.log"# 数据文件存放目录dir "/usr/local/redis/data"# 4、创建启动脚本方便操作
脚本支持效果如下：

在目录 [/usr/local/redis/] 下创建脚本文件 [ redis.sh ] 内容：
#!/bin/sh# Redis 启动脚本# # @author: hal@xhal.net 2022-08-06# 脚本当前目录SH_DIR=$(cd $( dirname $&#123;BASH_SOURCE[0] &#125; ) &amp;&amp; pwd)APP_NAME="redis-server"# 根路径#APP_PATH=/usr/local/redisAPP_PATH=$SH_DIRBIN_PATH=$APP_PATH/bin# 配置文件路径CONF_PATH=$APP_PATH/confCONF_FILE_PATH=$CONF_PATH/redis.confMASTER_CONF_FILE_PATH=$CONF_PATH/master.confSLAVE_CONF_FILE_PATH=$CONF_PATH/slave.conf# 运行端口 - 默认 6379APP_PORT=6379# Redis 密码 - 默认为空APP_PASS=""## 从配置文件，读取端口、密码CONFIG_STR=$(cat $CONF_FILE_PATH | grep -E '^port|^requirepass')#echo "CONFIG_STR: $CONFIG_STR"PORT_STR=$(echo -e $CONFIG_STR | sed 's/port \([0-9]*\).*/\1/g' )PASS_STR=$(echo -e $CONFIG_STR | sed 's/.*requirepass \(.*\)/\1/g' | sed 's/"//g')#echo "PORT_STR: $PORT_STR"#echo "PASS_STR: $PASS_STR"if [ -n "$PORT_STR" ]; then  APP_PORT=$PORT_STR;fiif [ -n "$PASS_STR" ]; then  APP_PASS=$PASS_STR;fi# 处理密码连接字符串PASS_KEY=""if [ -n "$APP_PASS" ]; then  PASS_KEY="-a $APP_PASS"fiecho -e "\e[35m======================================================================\e[0m"#使用说明 用来提示参数usage()&#123;  echo -e "\e[33mAPP_PATH:\e[0m \e[36m $APP_PATH \e[0m"  echo -e "\e[33mUsage:\e[0m    \e[36m $0 [start|stop|restart] \e[0m"  echo -e "\e[33mUsage:\e[0m    \e[36m $0 [status|running|role|slaveup] \e[0m"  echo -e "\e[33mUsage:\e[0m    \e[36m $0 [tomaster|toslave|startmaster|startslave|startauto] \e[0m"  echo -e "\e[35m----------------------------------------------------------------------\e[0m"  echo -e " -\e[32m start   \e[0m: 正常启动 Redis，$BIN_PATH/redis-server $CONF_FILE_PATH"  echo -e " -\e[32m stop    \e[0m: 停止 Redis, $BIN_PATH/redis-cli shutdown"  echo -e " -\e[32m restart \e[0m: 重启 Redis, stop &amp;&amp; start"  echo -e "\e[35m----------------------------------------------------------------------\e[0m"  echo -e " -\e[32m status  \e[0m: 当前运行状态、对应角色类型"  echo -e " -\e[32m running \e[0m: 当前运行状态，运行中返回 0，否则返回 1"  echo -e " -\e[32m role    \e[0m: 当前运行对应角色类型，master 返回 0， slave 返回 1, 其它 返回2， redis 未运行 返回9"  echo -e " -\e[32m slaveup \e[0m: 当前运行状态为slave时，master_link_status是否为up （是则返回0，否则为1）"  echo -e "\e[35m----------------------------------------------------------------------\e[0m"  echo -e " -\e[32m tomaster   \e[0m: 运行状态转换角色类型为【master】"  echo -e " -\e[32m toslave    \e[0m: 运行状态转换角色类型为【slave】"  echo -e " -\e[32m startmaster\e[0m: 未运行时，以【master】角色类型运行"  echo -e " -\e[32m startslave \e[0m: 未运行时，以【slave】角色类型运行"  echo -e " -\e[32m startauto  \e[0m: 未运行时，根据slave.conf的master节点状态，自动判断当前节点以【master/slave】角色类型运行"  echo ""  exit 1&#125;#检查程序是否已运行is_running()&#123;  # 根据应用名称，获取进程 pid (当存在多个时不适用)  #pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '&#123;print $2&#125;'`  # 根据端口号获取对应 pid  #pid=$(lsof -t -i:$APP_PORT)  pid=$(lsof -i:$APP_PORT | grep *: | awk '&#123;print $2&#125;')  #如果不存在返回 1 存在返回 0  if [ -z "$&#123;pid&#125;" ]; then   return 1  else   return 0  fi&#125;# 启动方法 start()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is already running . pid=$&#123;pid&#125;"  else     $BIN_PATH/redis-server $CONF_FILE_PATH    sleep 1    status    if [ $? -eq "0" ]; then      echo "$APP_NAME - [PORT: $APP_PORT] start success . pid=$&#123;pid&#125;"    else       echo "$APP_NAME - [PORT: $APP_PORT] start fail ."    fi  fi&#125;# 用 master.conf 的配置文件替换 redis.conf 后启动startmaster()&#123;  echo "准备以【 master 】模式启动，复制替换 redis.conf 文件..."  cp -f $MASTER_CONF_FILE_PATH $CONF_FILE_PATH  sleep 1  start  &#125;# 用 slave.conf 的配置文件替换 redis.conf 后启动startslave()&#123;  echo "准备以【 slave 】模式启动，复制替换 redis.conf 文件..."  cp -f $SLAVE_CONF_FILE_PATH $CONF_FILE_PATH  sleep 1  start&#125;# 自动判断当前启用 master 还是 slave 模式startauto()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is already running . pid=$&#123;pid&#125;"    exit 1  fi  # 读取 slave.conf 配置，获取对应 master 配置  arr=(`cat $SLAVE_CONF_FILE_PATH | grep ^replicaof`)  master_host=$&#123;arr[1]&#125;  master_port=$&#123;arr[2]&#125;  authcmd=$(cat $SLAVE_CONF_FILE_PATH | grep ^masterauth | sed 's/masterauth //g' | sed 's/"//g')  auth_key=""    if [ -n "$authcmd" ]; then    auth_key="-a $authcmd"  fi  echo "设置 master -h $master_host -p $master_port $auth_key "  # 判断 master 配置中的服务，对应角色类型  roleName=$($BIN_PATH/redis-cli -h $master_host -p $master_port $auth_key info | grep role: | sed 's/.$//g')    echo "slave 配置的 master 当前类型: $roleName"  if [ "$roleName" = "role:master" ]; then    startslave  else     startmaster  fi&#125;# 停止方法stop()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is running . pid=$&#123;pid&#125; ; stoping..."    # 执行 shutdown    $BIN_PATH/redis-cli $PASS_KEY shutdown      sleep 1    is_running    if [ $? -eq "0" ]; then      echo "$APP_NAME - [PORT: $APP_PORT] stop fail . pid=$&#123;pid&#125;"    else      echo "$APP_NAME - [PORT: $APP_PORT] stop success ."    fi    else     echo "$APP_NAME - [PORT: $APP_PORT] is not running ."  fi&#125;#重启restart()&#123;  stop  start&#125;# 判断运行的角色 [master, slave]# master 返回 0， slave 返回 1, 其它 返回 2， redis 未运行 返回 9role()&#123;  is_running  if [ $? -eq "0" ]; then    roleName=$($BIN_PATH/redis-cli $PASS_KEY info | grep role: | sed 's/.$//g')    if [ "$roleName" = "role:master" ]; then      return 0    elif [ "$roleName" = "role:slave" ]; then      return 1    else      #echo "ERROR: unknow role: [$roleName] !!!"      return 2    fi  else     #echo "$APP_NAME - [PORT: $APP_PORT] is not running ."    return 9  fi&#125;# 判断当前运行的 是否为 slave 且 正常连接上 master# 为简化逻辑，此处实现仅 在 info 信息中匹配 master_link_status:up （运行正常返回 0，否则为 1）# 即正常调用前，应该要知道此节点正常运行 且 为 slaveslaveup()&#123;  linkStatus=$($BIN_PATH/redis-cli $PASS_KEY info | grep master_link_status:up)  if [ -z "$linkStatus" ]; then   #echo "redis master link is down"   return 1  else    #echo "redis master link is up"   return 0  fi&#125;# Change Redis to master; Use Command:  replicaof no one tomaster()&#123;  role  mode=$?  if [ $mode -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] 已经是[ master ] 不必要切换 ."  elif [ $mode -eq "1" ]; then    # 切换配置文件 - 避免下次重启后变化    cp -f $MASTER_CONF_FILE_PATH $CONF_FILE_PATH    # 执行切换为 主服务    $BIN_PATH/redis-cli $PASS_KEY replicaof no one    sleep 1    status  else     echo "$APP_NAME - [PORT: $APP_PORT] 不支持操作状态 [$mode]."  fi&#125;# Change Redis to slave; Use Command:  replicaof masterip masterporttoslave()&#123;  role  mode=$?  if [ $mode -eq "1" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] 已经是[ slave ] 不必要切换 ."  elif [ $mode -eq "0" ]; then    # 切换配置文件 - 避免下次重启后变化    cp -f $SLAVE_CONF_FILE_PATH $CONF_FILE_PATH      authcmd=$(cat $CONF_FILE_PATH | grep ^masterauth | sed 's/"//g')    echo "设置 master 连接密码. $authcmd"    # 执行更新密码    $BIN_PATH/redis-cli $PASS_KEY config set $authcmd    repcmd=$(cat $CONF_FILE_PATH | grep ^replicaof)    echo "准备切换为[ slave ], $repcmd"    # 执行切换为 从服务    $BIN_PATH/redis-cli $PASS_KEY $repcmd      sleep 1    status  else    echo "$APP_NAME - [PORT: $APP_PORT] 不支持操作状态 [$mode]."  fi&#125;# 判断状态status()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is running . pid=$&#123;pid&#125;"    role    if [ $? -eq "0" ]; then      echo "Redis is master role"    elif [ $? -eq "1" ]; then      echo "Redis is slave role"    else       echo "Redis is unknow role"    fi  else     echo "$APP_NAME - [PORT: $APP_PORT] is not running ."  fi&#125;# 根据输入的参数执行对应的方法case "$1" in  "start")    start    ;;  "stop")    stop    ;;  "running")    is_running    ;;  "status")    status    ;;  "role")    role    ;;  "restart")    restart    ;;  "tomaster")    tomaster    ;;  "toslave")    toslave    ;;  "startmaster")    startmaster    ;;  "startslave")    startslave    ;;  "startauto")    startauto    ;;  "slaveup")    slaveup    ;;  *)    usage    ;;esac# 5、配置开机启动服务
在系统服务目录   /usr/lib/systemd/system/  下，创建  redis.service  文件
内容如下：
[Unit]# 服务描述Description=Redis-Server# 在 XX 服务后启动After=network.target# 服务运行参数； 注意本节点内命令要用绝对路径[Service]# 后台运行方式Type=forking# 启动命令ExecStart=/usr/local/redis/redis.sh start# 是否给服务分配独立的临时空间PrivateTmp=true# 运行级别下服务安装的相关设置， 可设置为多用户，即系统运行级别为 3[Install]WantedBy=multi-user.targetsystemctl daemon-reload           # 重载 systemdsystemctl enable redis.service    # 设置开机启动systemctl disable redis.service   # 停止开机启动systemctl start redis.service     # 启动服务systemctl stop redis.service      # 停止服务systemctl status redis.service    # 查看服务状态systemctl restart redis.service   # 重启服务systemctl list-units --type=service   # 查看所有已启动的服务]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.9使用yum安装Nginx</title>
    <url>/2022/04/eb7cc45c.html</url>
    <content><![CDATA[# Centos7.9 使用 yum 安装 Nginx
# 
在 CentOS 7.9 上使用 yum 安装 Nginx 非常简单。下面是几个简单步骤：
# 步骤一：更新系统
首先，您需要更新系统以获取最新的软件包和安全修复程序。使用以下命令更新系统：
sudo yum update# 步骤二：安装 nginx
安装 Nginx 非常简单，只需使用以下命令：
sudo yum install nginx然后开始安装过程，等待几分钟，Nginx 将安装在您的系统上。
‍
# 步骤三：启动 nginx 的服务
Nginx 安装完毕后，可以使用以下命令启动 Nginx 服务：
sudo systemctl start nginx启动命令行后，可以使用以下命令检查 Nginx 服务是否正在运行：
sudo systemctl status nginx# 步骤四：配置 Nginx
Nginx 的默认配置文件位于 /etc/nginx/nginx.conf 中。您可以根据需要更改配置文件。在更改配置之后，您需要重新启动 Nginx 服务。使用以下命令重新启动 Nginx 服务：
sudo systemctl restart nginxNginx 安装完毕，您可以尝试使用 Web 服务器上的 IP 地址或域名访问网站。
‍
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx/Openresty日志时间显示到毫秒级的三种方法(不改源码)</title>
    <url>/2022/09/f92ce47.html</url>
    <content><![CDATA[在这里，我们生成三个自定义变量
#以下为内置变量$time_iso8601  日期格式示例： 2022-09-08T18:16:01+08:00$time_local    日期格式示例： 02/Aug/2022:11:11:32 +0800$msec          日期格式示例： 1663839717.105 当前的Unix时间戳,单位为秒，小数为毫秒#生成自定义变量$time_zh    示例值： 2022-10-08 22:00:18$timestamp  示例值： 1663839717105$time_zh_ms 示例值： 2022-10-08 22:00:18,888# 方法一 ：set  （只能在 server 节点内）
建议创建独立 conf 文件，使用 include 方式，如： time-zh.conf   内容如下：
# 该 文件使用方法  在 nginx 配置 server 节点内：   include time-zh.conf;## nginx 内置变量，解析为定义格式，仅支持到秒 （实现支持到毫秒）## $time_iso8601  日期格式示例： 2022-09-08T18:16:01+08:00# $time_local    日期格式示例： 02/Aug/2022:11:11:32 +0800# $msec          日期格式示例： 1663839717.105 当前的 Unix 时间戳，单位为秒，小数为毫秒# 自定义变量 - 默认值#set $time_zh $time_iso8601;#set $timestamp $msec;#set $time_zh_ms $time_zh,000;# 格式化日期if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)(\+\d&#123;2&#125;)") &#123;  set $year   $1;  set $month  $2;  set $day    $3;  set $hour   $4;  set $minute $5;  set $second $6;  # 时区，只到小时  set $time_zone $7;  # 自定义 yyyy-MM-dd hh:mi:ss 格式  set $time_zh "$1-$2-$3 $4:$5:$6";&#125;# 时间戳，单位毫秒  使用 $msec 去除中间的小数点实现if ($msec ~ "^(\d+)\.(\d+)") &#123;  set $timestamp $1$2;  # 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式  set $time_zh_ms $time_zh,$2;&#125;# 方法二： set_by_lua （只能在 server 节点内）
建议创建独立 conf 文件，使用 include 方式，如： time-zh-lua.conf   内容如下：
# 该 文件使用方法  在 nginx 配置 server 节点内：   include time-zh-lua.conf;## nginx 内置变量，解析为定义格式，仅支持到秒 （实现支持到毫秒）## 取 ngx_lua 模块提供的带缓存的时间接口# ngx.now ()          日期格式示例： 1663839717.105  当前的 Unix 时间戳，单位为秒，小数为毫秒；与 nginx 内置变量 $msec 相同#                          -- 因 nginx 有缓存时间，所以与实际服务器时间会有些许偏差，可能偏差几毫秒 - 正常业务可忽略不计#                          -- 若 一定要强一致，可先调用 ngx.update_time () 强制更新，但成本较高，不推荐使用# ngx.time ()         日期格式示例： 1663839717  当前的 Unix 时间戳，单位为秒 (1970 年至今)# ngx.var.time_local 日期格式示例： 02/Aug/2022:11:11:32 +0800# ngx.utctime ()      日期格式示例： 2022-09-08 10:16:01# ngx.localtime ()    日期格式示例： 2022-09-08 18:16:01# ngx.today ()        日期格式示例： 2022-09-08## 本地时间（yyyy-MM-dd hh:mi:ss）set_by_lua $time_zh 'return ngx.localtime()';# Unix 时间戳，单位为毫秒set_by_lua $timestamp 'return ngx.now() * 1000';# 本地时间（yyyy-MM-dd hh:mi:ss,SSS）# 毫秒数： 先用 ngx.now ()%1, 取余数去除秒的部分，再 * 1000 获取毫秒部分，再用 math.floor + 0.5 四舍五入，再用 string.format 固定 3 位长度set_by_lua $time_zh_ms 'return ngx.localtime()..","..string.format("%03d", math.floor(ngx.now()%1*1000+0.5))';# 方法三： map （在 http 节点内）
建议创建独立 conf 文件，使用 include 方式，如： time-zh-map.conf   内容如下：
# 该 文件使用方法  在 nginx 配置 http 节点内：   include time-zh-map.conf;## nginx 内置变量，解析为定义格式，仅支持到秒## $time_iso8601  日期格式示例： 2022-09-08T18:16:01+08:00# $time_local    日期格式示例： 02/Aug/2022:11:11:32 +0800# $msec          日期格式示例： 1663839717.105 当前的 Unix 时间戳，单位为秒，小数为毫秒# 使用以下 map 必须增加 map_hash_bucket_size 大小，否则会报异常# 默认值为 cpu 的缓存行大小，一般为 64map_hash_bucket_size 128;# 自定义 yyyy-MM-dd hh:mi:ss 格式map $time_iso8601 $time_zh &#123;  default $time_iso8601;  "~(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)T(\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;)(\+\d&#123;2&#125;)" "$1 $2";&#125;# 时间戳，单位毫秒  使用 $msec 去除中间的小数点实现map $msec $timestamp &#123;  default $msec;  ~(\d+)\.(\d+) $1$2;&#125;# 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式map "$time_iso8601 # $msec" $time_zh_ms &#123;  default $time_zh,000;  "~(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)T(\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;)(\+\d&#123;2&#125;:\d&#123;2&#125;) # (\d+)\.(\d+)$" "$1 $2,$5";&#125;
PS: 若存在多个 Server, 推荐使用方法三，则不需要每个 server 配置一次

]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis7 源码安装</title>
    <url>/2023/01/dacefe23.html</url>
    <content><![CDATA[
源码安装 Redis7, 下载源码、解压、执行安装命令


# 1、下载 Redis 7 源码
可以从 Redis 官网（https://redis.io/download）或者 GitHub 上（https://github.com/redis/redis/releases）下载最新版本的 Redis 源码包，也可以使用以下命令下载最新的稳定版：
wget https://download.redis.io/releases/redis-7.0.0.tar.gz# 2、解压源码包
使用以下命令解压下载的源码包：
tar xzf redis-7.0.0.tar.gz# 3、编译安装
进入解压后的 Redis 目录，执行以下命令编译 Redis：
cd redis-7.0.0make这一步会生成 Redis 的可执行文件，包括 redis-server、redis-cli 等。
# 4、安装 Redis
执行以下命令安装 Redis：
make install这一步会将 Redis 可执行文件复制到 /usr/local/bin 目录下，并将 Redis 配置文件复制到 /etc/redis 目录下。
若需要指定安装目录，则添加 PREFIX  配置
# 指定 安装目录 PREFIXmake PREFIX=/usr/local/redis install# 5、配置 Redis
编辑 /etc/redis/redis.conf 配置文件，修改 Redis 的配置，例如修改监听的端口、设置密码、配置持久化等。
# 6、启动 Redis
执行以下命令启动 Redis：
redis-server /etc/redis/redis.conf如果 Redis 需要认证，还需要在启动 Redis 时指定密码：
redis-server /etc/redis/redis.conf --requirepass your_password# 7、测试 Redis
执行以下命令连接 Redis 并测试：
redis-cli127.0.0.1:6379> pingPONG如果 Redis 返回 PONG，则说明 Redis 已经正常运行。
以上是 Redis 7 源码安装的步骤，需要注意的是，在安装 Redis 时需要根据实际情况修改配置，例如修改监听的端口、设置密码、配置持久化等。同时，在部署 Redis 时，还需要注意安全性和性能等问题，例如限制 Redis 的网络访问权限、优化 Redis 的性能等。
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis+Keepalived_实现双机主从互备【互为主从、主从自动切换】</title>
    <url>/2022/10/8b778184.html</url>
    <content><![CDATA[
实际生产中，系统压力不大且仅两台物理服务器；实际一个 Redis 服务完全够用，但为了高可用及容灾备份，又不够哨兵模式的三台，所以做此实现方案。

# 1、资源配置：

实际服务器：
192.168.30.7【从】 、 192.168.30.8【主】
(Redis) 虚拟 IP: 192.168.30.6
 系统服务，配置连接此虚拟 IP 即可

# 2、在两台服务器上安装 Redis 安装目录  /usr/local/redis
安装步骤，可参考上篇教程：  Centos7.9 源码安装 Redis 5.x
**【必须用到】** 里面的启动脚本文件  redis.sh
# 3、增加 redis 配置文件  master.conf  /  slave.conf
在目录  /usr/local/redis/conf   下新增
 master.conf  从原  redis.conf  复制，配置文件两台服务器一样就行，如果有配置访问密码一定要一致
slave.conf  配置文件，主要区别如下：
192.168.30.8【主】配置：
# replicaof 配置对方 IP 端口replicaof 192.168.30.7  6379# 访问密码masterauth "xxx123"192.168.30.7【从】配置：
# replicaof 配置对方 IP 端口replicaof 192.168.30.8  6379# 访问密码masterauth "xxx123"配置文件修改完成后，启动服务：
启动 Redis 192.168.30.8【主】 以 【master】 方式启动
[root@centos7 redis]# /usr/local/redis/redis.sh startmaster启动 Redis 192.168.30.7【从】 以 【slave】 方式启动
[root@centos7 redis]# /usr/local/redis/redis.sh startslave# 4、支持 Keepalived 配置脚本文件
于目录  /usr/local/redis/  创建脚本  vip_keepalived.sh  （主从一样）：
#!/bin/sh# 虚拟 IP (Virtual IP) 检测实现 - keepalived 调用实现# # Keepalived vrrp_script 原理:#     根据调用的 script 脚本结果进行分析：#     -  如果执行结果【为 0】， 且 weight 配置的值【大于 0】，则优先级相应的【增加】#     -  如果执行结果【非 0】， 且 weight 配置的值【小于 0】，则优先级相应的【减少】# # 实现原理：   本方案 weight 配置的值 建议【大于 0】, priority 相等、preempt 模式#   1、检测当前节点服务是否正常、若正常且为 master 主节点，则使 vip 为指向本机#   2、若本机节点服务进程不存在（则由从节点判定），以下为从节点判断逻辑#      - 当前节点服务进程是否正常，若正常则判断下 redis 中的 role 是否为 slave#      - 如果是 slave ，判断 master_link_status 是否为 up#      - 如果不为 up, 则代表主节点连接不上，则修改本节点为 master, 则使 vip 为指向本节点##   PS: 本脚本需要配合 redis.sh 使用# @author hal@xhal.net 2022-09-08BASE_PATH=/usr/local/redis# 备份方案，仅检测服务状态 （此方案不能切换为 master）# 0 表示检查进程是否运行# /usr/bin/killall -0 redis-server # 本方案 weight 配置的值 建议【大于 0】, priority 相等、preempt 模式# 1、检测当前节点服务是否正常、若正常且为 master 主节点，返回 0 check()&#123;  # 判断运行的角色 [master, slave] master 返回 0， slave 返回 1, 其它 返回 2， redis 未运行 返回 9  $BASE_PATH/redis.sh role  redisRole=$?  echo "当前 redis role值： [$redisRole]"  if [ $redisRole -eq "0" ]; then    # redis 有运行，且为 master 主节点，返回 0    return 0  elif [ $redisRole -eq "1" ]; then    #echo "redis 有运行，且为 slave 状态"    # 判断 master_link_status 是否为 up    $BASE_PATH/redis.sh slaveup    if [ $? -eq "0" ]; then      #echo "slave 连接 master 正常"       return 1;    else       # slave 连接 master 已断开，修改本节点为 master      $BASE_PATH/redis.sh tomaster      return 0    fi  else    #echo "其它状态，直接返回对应结果 [$redisRole]"    return $redisRole  fi  #echo "redis 未运行，直接返回 1"  return 1&#125;check于目录  /usr/local/redis/  创建脚本  vip_log.sh  （主从一样）：
#!/bin/sh# 记录 Keepalived 切换事件日志# @author hal@xhal.net 2022-09-08now=$(date "+%Y-%m-%d %H:%M:%S")LOG_FILE_PATH=/usr/local/redis/logs/keepalived.logecho "$now -- $1" >> $LOG_FILE_PATH# 5、修改 Keepalived 配置
修改 192.168.30.8【主】 Keepalived 配置  /etc/keepalived/keepalived.conf
[root@centos7 redis]# vim /etc/keepalived/keepalived.conf! Configuration File for keepalived# Redis 相关配置，开始 =======================vrrp_script chk_redis &#123;    script "/usr/local/redis/vip_keepalived.sh "    interval 5 # 检测时间间隔    weight 88  # 如果条件成立的话【script 执行结果为 0】，则权重值按此增加    fall 2     # 定义检测失败的最大次数，如果设置为 3 表示请求失败 2 次时，就认为节点故障    rise 1     # 定义请求成功的次数，如果设置为 1 表示一次请求成功后，就认为节点恢复正常&#125;# 定义虚拟路由，VI_Redis 为虚拟路由的标示符，自己定义名称vrrp_instance VI_Redis &#123;    state BACKUP               # 来决定主从 MASTER BACKUP    interface ens192           # 绑定虚拟 IP 的网络接口，根据自己的机器填写    virtual_router_id 8        # 虚拟路由的 ID 号， 两个节点设置必须一样    mcast_src_ip 192.168.30.8  # 填写本机 ip    priority 100               # 节点优先级，主要比从节点优先级高    preempt                    # 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题    advert_int 1               # 组播信息发送间隔，两个节点设置必须一样，默认 1s    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    # 将 track_script 块加入 instance 配置块    track_script &#123;        chk_redis #执行 Redis 监控的服务    &#125;    # 变为 MASTER 后执行脚本    notify_master "/usr/local/redis/vip_log.sh to_be_【master】"    # 变为 BACKUP 后执行脚本    notify_backup "/usr/local/redis/vip_log.sh to_be_【slave】"    # 状态变为 FAULT 后执行脚本    notify_fault  "/usr/local/redis/vip_log.sh keepalived_is_Fault"    # VRRP 停止 后执行脚本    notify_stop  "/usr/local/redis/vip_log.sh keepalived_is_stop...!"    virtual_ipaddress &#123;        192.168.30.6 #虚拟 ip    &#125;&#125;修改完成后， 重启 keepalived
[root@centos7 redis]# systemctl restart keepalived.service修改 192.168.30.7【从】 Keepalived 配置  /etc/keepalived/keepalived.conf
[root@centos7 redis]# vim /etc/keepalived/keepalived.conf# Redis 相关配置，开始 =======================vrrp_script chk_redis &#123;    script "/usr/local/redis/vip_keepalived.sh "    interval 5 # 检测时间间隔    weight 88  # 如果条件成立的话【script 执行结果为 0】，则权重值按此增加    fall 2     # 定义检测失败的最大次数，如果设置为 3 表示请求失败 2 次时，就认为节点故障    rise 1     # 定义请求成功的次数，如果设置为 1 表示一次请求成功后，就认为节点恢复正常&#125;# 定义虚拟路由，VI_Redis 为虚拟路由的标示符，自己定义名称vrrp_instance VI_Redis &#123;    state BACKUP               # 来决定主从 MASTER BACKUP    interface ens192           # 绑定虚拟 IP 的网络接口，根据自己的机器填写    virtual_router_id 8        # 虚拟路由的 ID 号， 两个节点设置必须一样    mcast_src_ip 192.168.30.7  # 填写本机 ip    priority 100               # 节点优先级，主要比从节点优先级高    preempt                    # 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题    advert_int 1               # 组播信息发送间隔，两个节点设置必须一样，默认 1s    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    # 将 track_script 块加入 instance 配置块    track_script &#123;        chk_redis #执行 Redis 监控的服务    &#125;    # 变为 MASTER 后执行脚本    notify_master "/usr/local/redis/vip_log.sh to_be_【master】"    # 变为 BACKUP 后执行脚本    notify_backup "/usr/local/redis/vip_log.sh to_be_【slave】"    # 状态变为 FAULT 后执行脚本    notify_fault  "/usr/local/redis/vip_log.sh keepalived_is_Fault"    # VRRP 停止 后执行脚本    notify_stop  "/usr/local/redis/vip_log.sh keepalived_is_stop...!"    virtual_ipaddress &#123;        192.168.30.6 #虚拟 ip    &#125;	# 当存在 IP 冲突时，可指定单播 ip 为对方 IP    # unicast_peer &#123;    # 192.168.30.8  # 另一台 IP    #&#125;&#125;修改完成后， 重启 keepalived
[root@centos7 redis]# systemctl restart keepalived.service# 6、修改开机启动  redis.service  配置命令
[Unit]# 服务描述Description=Redis-Server# 在 XX 服务后启动After=network.target# 服务运行参数； 注意本节点内命令要用绝对路径[Service]# 后台运行方式Type=forking# 启动命令 (主要修改此部分由 start 修改为 startauto)ExecStart=/usr/local/redis/redis.sh startauto# 是否给服务分配独立的临时空间PrivateTmp=true# 运行级别下服务安装的相关设置， 可设置为多用户，即系统运行级别为 3[Install]WantedBy=multi-user.target]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux/Centos 环境Shell会话关闭后，本会话启动进程被终止</title>
    <url>/2023/02/37631c5.html</url>
    <content><![CDATA[
原因排查：Linux/Centos 环境 Shell 会话关闭后，本会话启动进程被终止
记录下工作中遇到的问题，希望给遇到的小伙伴参考


原文链接： Linux/Centos 环境 shell 会话关闭后，java 进程被结束
# 一、操作环境、软件版本等信息

Centos 7.9.2009
Java8

# 二、问题场景：

1、 原启动命令  java -jar xxx.jar &gt; test.log 2&gt;&amp;1 &amp;  在  start.sh  脚本文件里
2、有两台一样的服务器， 环境配置都一样； 之前一直是正常的（shell 会话关闭，也可正常运行）
3、其中一台重启后，手动上去执行此脚本启动后；会话关闭进程就没了

# 三、尝试过的解决方法

1、 在命令前增加  nohup  ， 尝试无效
2、 在命令前增加  nohup  ，并使用 exit 退出 shell 会话， 尝试无效
3、 检查设置参数 shopt huponexit huponexit 原本值就为 off, 尝试重新设置后， 一样无效
4、 使用  screen  启动， 尝试无效

# 四、最终排查原因 及 解决方案
# 问题原因：  SSH  版本被更新

没问题的服务器 SSH 版本（旧的）： 7.4p1
有问题的服务器 SSH 版本（新的）： 8.9p1

# 解决方案：
在  ssh@.service  中 [Service] 节点下，添加  KillMode=process  后
使用命令  systemctl restart sshd.service  重启 sshd 服务
参考连接：
https://www.cnblogs.com/byzgss/p/15573344.html
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>何谓立德、立功、立言（三不朽）</title>
    <url>/2022/03/7c550628.html</url>
    <content><![CDATA[
何谓立德、立功、立言（三不朽）


# “立德、立功、立言”：中国古代文人墨客的三大志向
中国文化源远流长，代表着中华民族的文化传统和精神内涵。在众多的传统文化中，文人墨客的文化是一种非常独特和重要的精神文化。在这种文化的背景下，“立德、立功、立言” 被称为文人墨客的 “三大志向”，也被称作 “三不朽” 或 “三绝”。
首先，“立德” 是指一个人要有高尚的道德品质和品行。中国先贤们认为：修身养性，有德者兴，无德者败。在古代，做人首先是要有道德修养，这样才能得到社会的认可和尊重。同时，德行高尚的人往往有良好的人际关系和内在的快乐体验，因此我们也可以从道德修养中找到一种内心的满足和平静。
其次，“立功” 指的是一个人要有卓越的成就和功绩。中国古代文人墨客认为，做人不能只停留在思想和理论层面，而应该付诸实践行动，创造出实际的成就。只有具有卓越成就和功绩的人才能够被后人所记取和传颂，成就卓越的人才能真正摆脱历史的洪流，立于不败之地。
最后，“立言” 是指一个人要有深刻的思想和理论成就，能够留下具有普遍意义、经久不衰的言论或著作。这一点显然是文字创作方面的应用，因为文字可以记录一个时代的思想、文化和价值观。留下的文字能够传承和延续文化精神，经过岁月的沉淀，其价值更能得到世人的确认和认同。
在 “立德、立功、立言” 的旗帜下，中国古代的文人墨客们做出了巨大的贡献。这三个方面被合称为 “三不朽”，意味着一个人只要在其中一个方面成就卓越，就能够成为历史人物，留名后世，永存不朽。这种理念在中国文化传统中一直被强调，也在全球文明史上留下了难以磨灭的印记。在这种精神文化的影响下，中国的文化才得以弥足珍贵，在世界的大舞台上崭露头角。
# 引用百度百科释义 三不朽

作品出处：《左传・襄公二十四年》
创作年代： 春秋时代
原文出处：
二十四年春，穆叔如晋。范宣子逆之，问焉，曰：“古人有言曰：‘死而不朽’，何谓也？” 穆叔未对。
宣子曰：“昔匄之祖，自虞以上为陶唐氏，在夏为御龙氏，在商为豕韦氏，在周为唐杜氏，晋主夏盟为范氏，其是之谓乎？”
穆叔曰：“以豹所闻，此之谓世禄，非不朽也。鲁有先大夫曰臧文仲，既没，其言立，其是之谓乎！
豹闻之，‘太上有立德，其次有立功，其次有立言’，虽久不废，此之谓不朽。若夫保姓受氏，以守宗祊，世不绝祀，无国无之，禄之大者，不可谓不朽。”

]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>古代</tag>
        <tag>名言</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos使用yum常用命令</title>
    <url>/2022/03/29184805.html</url>
    <content><![CDATA[
在部署过程中，经常要使用 yum 命令安装些组件； 记录下常用的命令参数


# 清理缓存信息
yum clean all# 更新缓存
yum makecache# 安装包 (最新版本)
yum install 包名（例如： redis）# 安装包 (指定版本)
yum install 带版本包名（例如： redis-5.1.2.x86_x64）# 仅下载（不安装）
yum install --downloadonly 包名（例如： redis）
默认情况下，下载的 RPM 包文件存放在以下目录
 /var/cache/yum/x86_64/[system version]/[repository]/packages

# 查找指定包
yum list|grep 包名或关键字（例如： redis）# 卸载指定包
yum remove 包名（例如： redis）rpm -e 包名（例如： redis）]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>Yum</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装Maven私服Nexus3</title>
    <url>/2022/05/cd130dc5.html</url>
    <content><![CDATA[
记录 Centos 安装 Maven 私服 Nexus3 过程


# Centos 安装 Maven 私服 Nexus3


创建 nexus 用户、设置密码
[root@aly-nexus local]# adduser nexus[root@aly-nexus local]# passwd nexus

以 nexus 用户登陆，上传 Nexus 包、解压至用户根目录
[nexus@aly-nexus ~]$ tar -zxvf nexus-3.29.2-02-unix.tar.gz

修改文件描述资源限制
[root@aly-nexus local]# vim /etc/security/limits.conf#@student        -       maxlogins       4*               soft    nofile           65536*               hard    nofile           65536# End of file

配置开机启动
[root@aly-nexus local]# vim /etc/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/local# 以 nexus 用户运行启动 nexus 服务su - nexus -c "/home/nexus/nexus-3.29.2-02/bin/nexus start"

以 nexus 用户登陆，手动启动服务
[nexus@aly-nexus ~]$ /home/nexus/nexus-3.29.2-02/bin/nexus start

启动成功后，访问地址： http:// 服务器 ip:8081
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装Tengine</title>
    <url>/2022/03/cca36461.html</url>
    <content><![CDATA[# Centos 安装 Tengine

记录下源码安装 Tengine 过程记录



下载及解压包
## 进入 /usr/local/ 目录[root@ss-aliyun home]# cd /usr/local/## 下载源码包[root@ss-aliyun local]# wget http://tengine.taobao.org/download/tengine-2.3.2.tar.gz## 解压[root@ss-aliyun local]# tar -zxvf tengine-2.3.2.tar.gz

cd 切换到 Tengine 解压目录
[root@ss-aliyun local]# cd tengine-2.3.2/[root@ss-aliyun tengine-2.3.2]#

配置安装，包含健康检查 check 模块 (默认安装目录   /usr/local/nginx )


[root@ss-aliyun tengine-2.3.2]# ./configure --add-module=modules/ngx_http_upstream_check_module[root@ss-aliyun tengine-2.3.2]# make[root@ss-aliyun tengine-2.3.2]# make install

开机启动
[root@ss-aliyun local]# vim /etc/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/local# 启动 nginx 服务/usr/local/nginx/sbin/nginx

配置 nginx.conf


PS: 此处删除了 默认 80 端口 静态 html 配置，若需要则在拓展  vhost/  目录下自己添加配置
#user  nobody;
worker_processes  auto;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#error_log  &quot;pipe:rollback logs/error_log interval=1d baknum=7 maxsize=2G&quot;;

#pid        logs/nginx.pid;


events &#123;
    worker_connections  1024;
&#125;


http &#123;
    include       mime.types;
    default_type  application/octet-stream;

    charset utf-8;

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #access_log  logs/access.log  main;
    #access_log  &quot;pipe:rollback logs/access_log interval=1d baknum=7 maxsize=2G&quot;  main;

    log_format xformat '$time_local - [$scheme $host] $remote_addr[$request] $status $body_bytes_sent '
                      '$upstream_addr - $upstream_response_time';
    access_log  logs/access.log xformat;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    gzip  on;

    include ./vhost/*.conf;
    
    #upstream dubbo_backend &#123;
    #    multi 1;
    #    server 127.0.0.1:20880;
    #&#125;

    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server &#123;
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;


    # HTTPS server
    #
    #server &#123;
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:2m;
    #    ssl_session_timeout  4h;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;
&#125;

]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Centos</tag>
        <tag>Tengine</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven插件[versions-maven-plugin]</title>
    <url>/2022/04/fbbabe1b.html</url>
    <content><![CDATA[
记录下 Maven 插件 [versions-maven-plugin] 的主要作用及使用方法


versions-maven-plugin 插件官网
# 以下为本插件命令清单

# Maven pom.xml 配置
&lt;plugin>  &lt;groupId>org.codehaus.mojo&lt;/groupId>  &lt;artifactId>versions-maven-plugin&lt;/artifactId>  &lt;version>2.10.0&lt;/version>  &lt;reportSets>    &lt;reportSet>      &lt;reports>        &lt;report>dependency-updates-report&lt;/report>        &lt;report>plugin-updates-report&lt;/report>        &lt;report>property-updates-report&lt;/report>      &lt;/reports>    &lt;/reportSet>  &lt;/reportSets>&lt;/plugin># 常用命令
# 更新项目版本，为指定版本号
mvn versions:set -DnewVersion=1.0.1-SNAPSHOT# 执行后正常会在 pom.xml 同级目录生成 pom.xml.versionsBackup 文件# 再使用确认提交命令，会清除 生成的 pom.xml.versionsBackup 文件mvn versions:commit# 如果想还原 pom.xml ，则执行以下命令 mvn versions:revert# 更新依赖 Jar 为 下一个 releases 版本
mvn versions:use-next-releases -T1C# 更新依赖 Jar 为 最新的 releases 版本
mvn versions:use-latest-releases -T1C# 更新下载依赖的 源码包 / JavaDoc 包
mvn dependency:sources -DdownloadSources=true -DdownloadJavadocs=true -T1C# 显示可更新版本的 maven 插件
mvn versions:display-plugin-updates -T1CPS: 更多使用方法，请访问 官网使用示例
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>【ChatGPT】给我写一首歌，关键词：love，sea</title>
    <url>/2023/03/27c52b84.html</url>
    <content><![CDATA[
现在 ChatGPT 大火，也试着让他写一首歌试试；记录下


# 歌曲名：海洋之恋
(Verse 1)
G    D    Em  C
 海洋星空满天下
 G    D    Em  C
 海浪声声宛如歌
 G    D    Em  C
 你的眼中有无尽
 G    D    Em  C
 深情永存我心坎
(Chorus)
G    D    Em  C
 爱情似海一般宽广
 G    D    Em  C
 充满欢乐充满平静
 G    D    Em  C
 像海浪一样不停的起伏
 G    D    Em  C
 带给我们无尽的希望
(Verse 2)
G    D    Em  C
 海边散步与你相依
 G    D    Em  C
 心跳声声共鸣悠长
 G    D    Em  C
 沙滩上的足印纹迹
 G    D    Em  C
 证明永恒的爱情绝不褪色
(Bridge)
Am   G    D   C
 有时海浪狂暴无常
 Am   G    D   C
 但爱情却能镇定内心
 Am   G    D   C
 当风暴来临带来变革
 Am   G    D   C
 我们的爱情不变，继续成长
(Chorus)
G    D    Em  C
 爱情似海一般宽广
 G    D    Em  C
 充满欢乐充满平静
 G    D    Em  C
 像海浪一样不停的起伏
 G    D    Em  C
 带给我们无尽的希望
(Outro)
G    D    Em  C
 海洋星空满天下
 G    D    Em  C
 我们的爱情生生不息
 G    D    Em  C
 你的眼中有无尽
 G    D    Em  C
 深情永存我心坎

PS:  G D Em C
这些是吉他和弦符号，用来表示在这个歌曲中需要弹奏的和弦。
具体来说，G 表示吉他上的 G 大调和弦，D 表示 D 大调和弦，Em 表示 E 小调和弦，C 表示 C 大调和弦。在这个曲谱中，吉他手需要弹奏这些和弦来伴奏歌曲。

]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
        <tag>AI</tag>
        <tag>创作</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】此生为人，实属意外</title>
    <url>/2023/03/130185c4.html</url>
    <content><![CDATA[
[转] 此生为人，实属意外，因无经验参照，不尽仁义之处，还请多多担待！


此生为人，实属意外。本人出身耕农之家，落地时天无异象。
父母识字略过百，茅屋三间遮身，非书香门第。
几亩瘦田刨食，得以苟活幸存，全杖上天垂青，得益母爱父恩，方能蜷缩在万丈红尘。
八年学堂混个初本，弃笔从戎，未建盖世功勋。
虽命比纸薄，心恨天高。
匍匐人间，百折不挠，隐入尘烟，偶得逍遥。
学富虽无五车，却喜舞文弄墨。
居于市井窥视庙堂，偶尔故作高深，装模作样。
人前不敢卸下伪装，人后不敢直视内心肮脏。
做好人不能由始及终，行坏事不敢彻底放纵。
贪财又恐世俗不容，好色时常胆怂。
既非混世魔王，也非盖世英雄；
见庙烧香，遇佛也拜，酒肉均沾；
放生时慈悲为怀，杀生时手起刀快，既辜负了观音，也辜负了如来。
蹉跎半生，无傲人过往可寻，展望未来，亦缺少年雄心，苟且红尘偷生，虚度年华光阴。
愧疚为人子，未能尽人之孝行，让父母安心；不安为人父，未担起父之责任，承子女欢情。
自责为人有友，未对友肝胆赤诚。空叹世间知己难寻呐。
此生为人，实属意外，因无经验参照，不尽仁义之处，还请多多担待！
]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows切换JDK版本（Bat脚本）</title>
    <url>/2023/03/1e014c62.html</url>
    <content><![CDATA[
当我们系统中有多个 JDK 版本时，要切换时每次都要手动修改：
右键打开我的电脑 &gt;&gt; 属性 &gt;&gt; 系统高级设置 &gt;&gt; 环境变量， 修改 JAVA_HOME 的值
非常麻烦，所以写个脚本，一键搞定；

先来看看效果：

我们将 JDK 统一放置在同一个目录下，比如  D:\Env\Java
脚本简单实现逻辑，就是将这指定目录下，所有子目录都找出来，并按顺序生成编号
脚本根据用户输入的编号对应的目录，更新环境变量  JAVA_HOME
脚本内容如下 (特别注意： 使用 GBK 编码保存脚本文件，否则会中文乱码)：
@echo off:: 获取管理员执行权限%1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&amp;&amp;exitcd /d "%~dp0":: 设置容器大小 及 标题mode con cols=120 lines=30title JDK-Version change script of Batsetlocal EnableDelayedExpansion:menuecho 当前 JDK 版本:echo --------------------------------------------------------java -versionecho.echo.echo ========================================================echo ################ JDK 版本切换，可选操作 ################echo.echo          [0]  取消切换set "options="set "count=0":: 指定根目录，遍历子文件夹for /d %%d in ("D:\Env\Java\*") do (    set /a "count+=1"    set "options=!options! !count!"    set "dir[!count!]=%%d")::echo Select a directory:for %%i in (%options%) do (    echo          [%%i]  切换至版本： !dir[%%i]!)echo.echo ========================================================echo.:tipsChooseset /p "choice=Enter the number of your choice: "if "%choice%" EQU "0" (       goto exit) else if %choice% gtr %count% (    echo 请输入[ 0 -- %count% ]范围内的数字    echo 》》》    goto tipsChoose)set "JAVA_HOME=!dir[%choice%]!"if "!JAVA_HOME!" == "" (    echo 获取的目录为空，请输入正确范围内的数字！    goto tipsChoose)setx JAVA_HOME "!JAVA_HOME!" /mecho JAVA_HOME 已切换至： !JAVA_HOME!echo 按任意键退出.. &amp; pause > nul:exit]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7源码安装PostgreSQL15</title>
    <url>/2022/12/54208668.html</url>
    <content><![CDATA[
# CentOS 7 源码安装 PostgreSQL
# 环境信息

系统版本： CentOS 7.9.2009 x86_64
PostgreSQL 版本号：15.0

# 资源准备

PostgreSQL 官网下载 url: https://ftp.postgresql.org/pub/source/v15.0/postgresql-15.0.tar.gz

[root@VM-20-8-centos downloads]# wget https://ftp.postgresql.org/pub/source/v15.0/postgresql-15.0.tar.gz# 环境准备
# 安装必要组件[root@VM-20-8-centos downloads]# yum -y install gcc gcc-c++ readline-devel zlib-devel# 安装步骤

解压下载的压缩包

[root@VM-20-8-centos downloads]# tar -zxf postgresql-15.0.tar.gz [root@VM-20-8-centos downloads]# lldrwxrwxrwx 6 1107 1107     4096 Oct 11 05:01 postgresql-15.0-rw-r--r-- 1 root root 29385837 Oct 11 05:01 postgresql-15.0.tar.gz# 进入解压目录，使用 ./configure 编译[root@VM-20-8-centos downloads]# cd postgresql-15.0/[root@VM-20-8-centos postgresql-15.0]# ./configure...... 以上省略N行configure: using compiler=gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)configure: using CFLAGS=-Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -O2configure: using CPPFLAGS= -D_GNU_SOURCE configure: using LDFLAGS=  -Wl,--as-neededconfigure: creating ./config.statusconfig.status: creating GNUmakefileconfig.status: creating src/Makefile.globalconfig.status: creating src/include/pg_config.hconfig.status: creating src/include/pg_config_ext.hconfig.status: creating src/interfaces/ecpg/include/ecpg_config.hconfig.status: linking src/backend/port/tas/dummy.s to src/backend/port/tas.sconfig.status: linking src/backend/port/posix_sema.c to src/backend/port/pg_sema.cconfig.status: linking src/backend/port/sysv_shmem.c to src/backend/port/pg_shmem.cconfig.status: linking src/include/port/linux.h to src/include/pg_config_os.hconfig.status: linking src/makefiles/Makefile.linux to src/Makefile.port
执行安装命令

[root@VM-20-8-centos postgresql-15.0]# make &amp;&amp; make install...... 以上省略N行make[1]: Leaving directory `/home/downloads/postgresql-15.0/src'make -C config installmake[1]: Entering directory `/home/downloads/postgresql-15.0/config'/usr/bin/mkdir -p '/usr/local/pgsql/lib/pgxs/config'/usr/bin/install -c -m 755 ./install-sh '/usr/local/pgsql/lib/pgxs/config/install-sh'/usr/bin/install -c -m 755 ./missing '/usr/local/pgsql/lib/pgxs/config/missing'make[1]: Leaving directory `/home/downloads/postgresql-15.0/config'[root@VM-20-8-centos postgresql-15.0]#以上命令执行成功后，默认会创建目录  /usr/local/pgsql
[root@VM-20-8-centos postgresql-15.0]# cd /usr/local/pgsql/[root@VM-20-8-centos pgsql]# lltotal 16drwxr-xr-x 2 root root 4096 Oct 13 22:50 bindrwxr-xr-x 6 root root 4096 Oct 13 22:50 includedrwxr-xr-x 4 root root 4096 Oct 13 22:50 libdrwxr-xr-x 6 root root 4096 Oct 13 22:50 share
创建系统用户、配置权限（以上操作如果是 root 用户执行，否则跳过此步骤）

# 添加用户[root@VM-20-8-centos pgsql]# useradd postgres# 设置密码 （特别注意： 如果是外网环境，千万不要设置简单的密码或甚至同账号，否则很容易被黑客攻破）[root@VM-20-8-centos pgsql]# echo 'post@gres@qw_231' | passwd --stdin postgresChanging password for user postgres.passwd: all authentication tokens updated successfully.# 目录授权给新建用户 postgres[root@VM-20-8-centos pgsql]# cd ..[root@VM-20-8-centos local]# chown -R postgres:postgres pgsql/[root@VM-20-8-centos local]# cd pgsql/[root@VM-20-8-centos pgsql]# lltotal 16drwxr-xr-x 2 postgres postgres 4096 Oct 13 22:50 bindrwxr-xr-x 6 postgres postgres 4096 Oct 13 22:50 includedrwxr-xr-x 4 postgres postgres 4096 Oct 13 22:50 libdrwxr-xr-x 6 postgres postgres 4096 Oct 13 22:50 share
初始化数据库

# 进入 bin 目录，查看可用 命令[root@VM-20-8-centos pgsql]# cd bin/[root@VM-20-8-centos bin]# lltotal 13732-rwxr-xr-x 1 postgres postgres   83936 Oct 13 22:50 clusterdb-rwxr-xr-x 1 postgres postgres   88264 Oct 13 22:50 createdb-rwxr-xr-x 1 postgres postgres   88464 Oct 13 22:50 createuser-rwxr-xr-x 1 postgres postgres   79152 Oct 13 22:50 dropdb-rwxr-xr-x 1 postgres postgres   79096 Oct 13 22:50 dropuser-rwxr-xr-x 1 postgres postgres 1013232 Oct 13 22:50 ecpg-rwxr-xr-x 1 postgres postgres  148752 Oct 13 22:50 initdb-rwxr-xr-x 1 postgres postgres  115192 Oct 13 22:50 pg_amcheck-rwxr-xr-x 1 postgres postgres   48640 Oct 13 22:50 pg_archivecleanup-rwxr-xr-x 1 postgres postgres  156904 Oct 13 22:50 pg_basebackup-rwxr-xr-x 1 postgres postgres  207232 Oct 13 22:50 pgbench-rwxr-xr-x 1 postgres postgres   67624 Oct 13 22:50 pg_checksums-rwxr-xr-x 1 postgres postgres   47088 Oct 13 22:50 pg_config-rwxr-xr-x 1 postgres postgres   61616 Oct 13 22:50 pg_controldata-rwxr-xr-x 1 postgres postgres   77256 Oct 13 22:50 pg_ctl-rwxr-xr-x 1 postgres postgres  408376 Oct 13 22:50 pg_dump-rwxr-xr-x 1 postgres postgres  115840 Oct 13 22:50 pg_dumpall-rwxr-xr-x 1 postgres postgres   78712 Oct 13 22:50 pg_isready-rwxr-xr-x 1 postgres postgres  103552 Oct 13 22:50 pg_receivewal-rwxr-xr-x 1 postgres postgres  103792 Oct 13 22:50 pg_recvlogical-rwxr-xr-x 1 postgres postgres   71760 Oct 13 22:50 pg_resetwal-rwxr-xr-x 1 postgres postgres  193768 Oct 13 22:50 pg_restore-rwxr-xr-x 1 postgres postgres  152224 Oct 13 22:50 pg_rewind-rwxr-xr-x 1 postgres postgres   54064 Oct 13 22:50 pg_test_fsync-rwxr-xr-x 1 postgres postgres   43336 Oct 13 22:50 pg_test_timing-rwxr-xr-x 1 postgres postgres  167208 Oct 13 22:50 pg_upgrade-rwxr-xr-x 1 postgres postgres  123584 Oct 13 22:50 pg_verifybackup-rwxr-xr-x 1 postgres postgres  118088 Oct 13 22:50 pg_waldump-rwxr-xr-x 1 postgres postgres 9006040 Oct 13 22:50 postgreslrwxrwxrwx 1 postgres postgres       8 Oct 13 22:50 postmaster -> postgres-rwxr-xr-x 1 postgres postgres  699088 Oct 13 22:50 psql-rwxr-xr-x 1 postgres postgres   93152 Oct 13 22:50 reindexdb-rwxr-xr-x 1 postgres postgres   97472 Oct 13 22:50 vacuumdb# 查看 初始化 db help[root@VM-20-8-centos bin]# ./initdb --helpinitdb initializes a PostgreSQL database cluster.Usage:  initdb [OPTION]... [DATADIR]Options:  -A, --auth=METHOD         default authentication method for local connections      --auth-host=METHOD    default authentication method for local TCP/IP connections      --auth-local=METHOD   default authentication method for local-socket connections [-D, --pgdata=]DATADIR     location for this database cluster  -E, --encoding=ENCODING   set default encoding for new databases  -g, --allow-group-access  allow group read/execute on data directory      --icu-locale=LOCALE   set ICU locale ID for new databases  -k, --data-checksums      use data page checksums      --locale=LOCALE       set default locale for new databases      --lc-collate=, --lc-ctype=, --lc-messages=LOCALE      --lc-monetary=, --lc-numeric=, --lc-time=LOCALE                            set default locale in the respective category for                            new databases (default taken from environment)      --no-locale           equivalent to --locale=C      --locale-provider=&#123;libc|icu&#125;                            set default locale provider for new databases      --pwfile=FILE         read password for the new superuser from file  -T, --text-search-config=CFG                            default text search configuration  -U, --username=NAME       database superuser name  -W, --pwprompt            prompt for a password for the new superuser  -X, --waldir=WALDIR       location for the write-ahead log directory      --wal-segsize=SIZE    size of WAL segments, in megabytesLess commonly used options:  -d, --debug               generate lots of debugging output      --discard-caches      set debug_discard_caches=1  -L DIRECTORY              where to find the input files  -n, --no-clean            do not clean up after errors  -N, --no-sync             do not wait for changes to be written safely to disk      --no-instructions     do not print instructions for next steps  -s, --show                show internal settings  -S, --sync-only           only sync database files to disk, then exitOther options:  -V, --version             output version information, then exit  -?, --help                show this help, then exitIf the data directory is not specified, the environment variable PGDATAis used.Report bugs to &lt;pgsql-bugs@lists.postgresql.org>.PostgreSQL home page: &lt;https://www.postgresql.org/>我们指定工作数据目录为  /usr/local/pgsql/data  (可以是任意其它地址)
[root@VM-20-8-centos bin]# ./initdb /usr/local/pgsql/datainitdb: error: cannot be run as rootinitdb: hint: Please log in (using, e.g., "su") as the (unprivileged) user that will own the server process.# 提示不可用 root 用户执行，切换为刚刚新建的用户 postgres[root@VM-20-8-centos bin]# su - postgresLast failed login: Thu Oct 13 10:16:54 CST 2022 from 142.93.208.41 on ssh:nottyThere were 38 failed login attempts since the last successful login.[postgres@VM-20-8-centos ~]$ cd /usr/local/pgsql/bin/# 进入 pgsql/bin 目录，再次执行[postgres@VM-20-8-centos bin]$ ./initdb /usr/local/pgsql/dataThe files belonging to this database system will be owned by user "postgres".This user must also own the server process.The database cluster will be initialized with locale "en_US.UTF-8".The default database encoding has accordingly been set to "UTF8".The default text search configuration will be set to "english".Data page checksums are disabled.creating directory /usr/local/pgsql/data ... okcreating subdirectories ... okselecting dynamic shared memory implementation ... posixselecting default max_connections ... 100selecting default shared_buffers ... 128MBselecting default time zone ... Asia/Shanghaicreating configuration files ... okrunning bootstrap script ... okperforming post-bootstrap initialization ... oksyncing data to disk ... okinitdb: warning: enabling "trust" authentication for local connectionsinitdb: hint: You can change this by editing pg_hba.conf or using the option -A, or --auth-local and --auth-host, the next time you run initdb.Success. You can now start the database server using:    pg_ctl -D /usr/local/pgsql/data -l logfile start
启动数据库

[postgres@VM-20-8-centos data]$ /usr/local/pgsql/bin/pg_ctl -D /usr/local/pgsql/data/ -l /usr/local/pgsql/logs/logfile.log startwaiting for server to start.... doneserver started# 查看启用端口及进程[postgres@VM-20-8-centos data]$ netstat -ntlp | grep postgres(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN      911/postgres        tcp6       0      0 ::1:5432                :::*                    LISTEN      911/postgres
进入  /usr/local/pgsql/bin  目录，创建用户、数据库及授权

# psql 进入命令行[postgres@VM-20-8-centos bin]$ ./psql psql (15.0)Type "help" for help.# 创建用户 及 配置密码postgres=# create user platform with password 'x_platform_zxdvf12Ll';CREATE ROLE# 创建数据库 指定 所属用户postgres=# create database x_platform owner platform;CREATE DATABASE# 授权 对应 数据库 所有权限 给用户postgres=# GRANT ALL PRIVILEGES ON DATABASE x_platform to platform;GRANT# 退出命令行postgres=# \q[postgres@VM-20-8-centos bin]$
psql 登陆数据库

# -U 指定用户，-d 指定数据库，-h 指定服务器，-p 指定端口[postgres@VM-20-8-centos bin]$ ./psql -U platform -d x_platform -h 127.0.0.1 -p 5432psql (15.0)Type "help" for help.x_platform=>
停止、重启命令

# 停止  pg_ctl stop -D $PGDATA -m smart     # 等所有的连接终止后关闭数据库。如果客户端连接不终止，则无法关闭数据库# 停止  pg_ctl stop -D $PGDATA -m fast      # 相当于 oracle 数据库的 immdiate 模式# 停止  pg_ctl stop -D $PGDATA -m immediate # 相当于 oracle 数据库的 abort 模式/usr/local/pgsql/bin/pg_ctl stop -D /usr/local/pgsql/data/ -m smart# 重启/usr/local/pgsql/bin/pg_ctl -D /usr/local/pgsql/data/ -l /usr/local/pgsql/logs/logfile.log restart
备份，还原

# dump 备份至文件# 命令格式： ./pg_dump -U 用户名 -h 127.0.0.1 -p 5432 数据库名 > 备份至文件名[postgres@VM-20-8-centos bin]$ ./pg_dump -U platform -h 127.0.0.1 -p 5432 x_platform > /home/postgres/x_platform_14-20221014.bakPassword: 输入对应数据库账号的密码# 恢复数据库，还原 dump 文件# pg_dump 创建的备份文件可以被工具 psql 识别。因此可以使用 psql 来读取 pg_dump 创建的备份文件，实现恢复数据库的功能。例如：# 命令格式： psql 数据库名 &lt; 备份至文件名# 命令格式： psql -U 用户名 -h 127.0.0.1 -p 5432 数据库名 &lt; 备份至文件名# 指定的数据库必须已经存在。如果不存在，用户应当先创建 dbname 指定的数据库，然后再执行恢复数据的命令。# psql 也支持和 pg_dump 一样的命令行选项，如 - h 和 - p 等。创建数据库 dbname 时，必须使用 template0 作为模板数据库，可以使用工具 createdb 创建数据库# 也可以在 psql 中执行 SQL 命令 create database 来创建数据库。下面是两个实例：#（1）createdb -T template0 dbname（数据库名）#（2）create database dbname template=template0[postgres@VM-20-8-centos bin]$ ./psql -U platform -h 127.0.0.1 -p 5432 数据库名 &lt; 备份至文件名# 安装方式二（RPM 安装方式）：
# Install the repository RPM:sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-6-x86_64/pgdg-redhat-repo-latest.noarch.rpm# Install PostgreSQL:sudo yum install -y postgresql14-server# Optionally initialize the database and enable automatic start:sudo service postgresql-14 initdbsudo chkconfig postgresql-14 onsudo service postgresql-14 start# Linux 启动 PostgreSQL 通用脚本  z_postgres.sh
#!/bin/sh## Copyright (c) xhal.cc 2022. All Rights Reserved.# Project Name: platform# Author: Hal [hal@xhal.net]# Date: 2022/10/17 下午 8:59# Version: 1.0# LastModified: 2022/10/17 下午 8:59### Linux 启动 PostgreSQL 通用脚本##进入当前目录BASE_PATH=/usr/local/pgsqlBASE_BIN_PATH=$BASE_PATH/binDATA_PATH=$BASE_PATH/data/LOG_FILE_PATH=/usr/local/pgsql/logs/logfile.logPROCESS_NAME=postgres# PostgreSQL 默认端口 5432PROCESS_PORT=5432#使用说明 用来提示参数usage()&#123;  echo "Usage: sh 脚本名.sh [start|stop|restart|status]"  exit 1&#125;#检查程序是否已运行is_exist()&#123;  # 根据应用名称，获取进程 pid  (当存在多个时不适用)  # pid=$(ps -ef|grep $PROCESS_NAME|grep -v grep|awk '&#123;print $2&#125;')  # 根据端口号 获取对应 pid (需要 root 权限)  # pid=$(netstat -nlp | grep :$PROCESS_PORT | awk '&#123;print $7&#125;' | awk -F"/" '&#123; print $1 &#125;');  pid=$(lsof -t -i:$PROCESS_PORT)  #如果不存在返回 1 存在返回 0  if [ -z "$&#123;pid&#125;" ]; then   return 1  else   return 0  fi&#125;#启动方法start()&#123;  is_exist  if [ $? -eq "0" ]; then    echo "$&#123;PROCESS_NAME&#125; - [PORT:$&#123;PROCESS_PORT&#125;] is already running .pid =$&#123;pid&#125; ."  else    echo $BASE_PATH/$PROCESS_NAME	  $BASE_BIN_PATH/pg_ctl -D $DATA_PATH -l $LOG_FILE_PATH start    echo "$&#123;PROCESS_NAME&#125; - [PORT:$&#123;PROCESS_PORT&#125;] start success"  fi&#125;#停止方法stop()&#123;  is_exist  if [ $? -eq "0" ]; then    # 停止  pg_ctl stop -D $PGDATA -m smart     # 等所有的连接终止后关闭数据库。如果客户端连接不终止，则无法关闭数据库    # 停止  pg_ctl stop -D $PGDATA -m fast      # 相当于 oracle 数据库的 immdiate 模式    # 停止  pg_ctl stop -D $PGDATA -m immediate # 相当于 oracle 数据库的 abort 模式    $BASE_BIN_PATH/pg_ctl stop -D $DATA_PATH -m smart  else    echo "$&#123;PROCESS_NAME&#125; - [PORT:$&#123;PROCESS_PORT&#125;] is not running"  fi&#125;#输出状态status()&#123;  is_exist  if [ $? -eq "0" ]; then    echo "$&#123;PROCESS_NAME&#125; - [PORT:$&#123;PROCESS_PORT&#125;] is running . pid is $&#123;pid&#125;"  else    echo "$&#123;PROCESS_NAME&#125; - [PORT:$&#123;PROCESS_PORT&#125;] is not running"  fi&#125;#重启restart()&#123;  $BASE_BIN_PATH/pg_ctl -D $DATA_PATH -l $LOG_FILE_PATH restart&#125;#根据输入参数执行对应的方法，不输入则执行使用说明case "$1" in  "start")    start	;;  "stop")    stop	;;  "status")    status	;;  "restart")    restart	;;  *)    usage	;;esac]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>让ChatGPT教你使用Hexo搭建博客</title>
    <url>/2023/03/c3f3fbf7.html</url>
    <content><![CDATA[
问 ChatGPT:  怎么用 hexo 搭建一个博客网站


# 使用 Hexo 搭建博客网站
Hexo 是一个快速、简洁且高效的博客框架，它使用 Markdown 解析文章，支持 EJS、Swig 等模板引擎渲染页面，可以快速生成静态网页。
# 安装 Node.js
Hexo 是基于 Node.js 的，所以需要先安装 Node.js。可以在 Node.js 官网下载安装包进行安装。
# 安装 Hexo
安装 Node.js 之后，就可以使用 npm 安装 Hexo 了。在命令行中输入以下命令：
npm install -g hexo-cli# 初始化博客
安装 Hexo 之后，需要初始化博客。在命令行中进入想要存放博客的目录，然后输入以下命令：
hexo init blogcd blognpm install# 生成静态页面
在博客目录下，输入以下命令可以生成静态页面：
hexo generate    # 可使用简短命令  hexo g# 启动本地服务器
在博客目录下，输入以下命令可以启动本地服务器：
hexo server   # 可使用简短命令  hexo s# 发布博客
在博客目录下，输入以下命令可以发布博客：
hexo deploy    # 可使用简短命令  hexo d# 更换主题
Hexo 支持更换主题，可以在 Hexo 官网下载主题，然后将主题解压到博客目录下的 themes 文件夹中，最后在博客目录下的_config.yml 文件中修改 theme 字段为主题名称即可。
# 编写文章
在博客目录下，输入以下命令可以新建一篇文章：
hexo new MyNewPost新建的文章会在博客目录下的 source/_posts 文件夹中生成一个 Markdown 文件，可以使用 Markdown 语法编写文章

问 ChatGPT: 怎么配置使用 hexo admin

# 使用 Hexo Admin 管理博客
Hexo Admin 是一个基于 Web 的 Hexo 博客管理工具，可以方便地管理博客文章、页面、标签、分类、设置等内容。
# 安装 Hexo Admin
在博客目录下，输入以下命令可以安装 Hexo Admin：
npm install --save hexo-admin# 启用 Hexo Admin
在博客目录下的_config.yml 文件中添加以下配置：
# Hexo Adminadmin:  username: admin  password_hash: 098f6bcd4621d373cade4e832627b4f6 # admin  secret: a-secret-used-to-protect-your-password  deployCommand: hexo deploy其中，username 为管理员用户名，password_hash 为管理员密码的 MD5 值，可以使用 MD5 在线加密进行加密，secret 为用于保护密码的密钥，deployCommand 为发布博客的命令。
# 启动 Hexo Admin
在博客目录下，输入以下命令可以启动 Hexo Admin：
hexo server -d然后在浏览器中访问    http://localhost:4000/admin
即可进入 Hexo Admin 管理界面。
# 编写文章
在 Hexo Admin 管理界面中，可以方便地新建、编辑、删除文章，也可以管理页面、标签、分类、设置等内容。
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
        <tag>AI</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
