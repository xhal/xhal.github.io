<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7.9_源码安装Openresty1.21.4.1</title>
    <url>/2022/09/333f749f.html</url>
    <content><![CDATA[# 1、环境及版本
系统版本： Centos 7.9.2009
Openresty:  1.21.4.1
# 2、必要组件安装 (执行 yum 命令安装)
yum install openssl-devel gcc curl pcre-devel -y# 3、获取安装包、解压
访问官网地址： https://openresty.org
获取下载链接： https://openresty.org/download/openresty-1.21.4.1.tar.gz
# 切换到目录cd /usr/local# wget 下载安装包wget  https://openresty.org/download/openresty-1.21.4.1.tar.gz# 解压命令tar -zxvf openresty-1.21.4.1.tar.gz# 进入解压目录cd openresty-1.21.4.1# 4、修改源码，以支持  ip_hash  可以在内网同网段生效，以实现负载均衡
[root@nginx openresty-1.21.4.1]# vim bundle/nginx-1.21.4/src/http/modules/ngx_http_upstream_ip_hash_module.c...# 修改位置一：  第 80 行，数字 3 改为 4 ngx_http_upstream_ip_hash_pseudo_addr [3] 修改为 ngx_http_upstream_ip_hash_pseudo_addr [4] 80 static u_char ngx_http_upstream_ip_hash_pseudo_addr[3];81 ...# 修改位置二：  第 124 行，数字 3 改为 4; [iphp->addrlen = 3] 修改为 [iphp->addrlen = 4] 121     case AF_INET:122         sin = (struct sockaddr_in *) r->connection->sockaddr;123         iphp->addr = (u_char *) &amp;sin->sin_addr.s_addr;124         iphp->addrlen = 3;125         break;126 127 #if (NGX_HAVE_INET6)128     case AF_INET6:129         sin6 = (struct sockaddr_in6 *) r->connection->sockaddr    ;130         iphp->addr = (u_char *) &amp;sin6->sin6_addr.s6_addr;131         iphp->addrlen = 16;132         break;133 #endif134 # 修改位置三：  第 137 行，数字 3 改为 4; [iphp->addrlen = 3] 修改为 [iphp->addrlen = 4] 135     default:136         iphp->addr = ngx_http_upstream_ip_hash_pseudo_addr;137         iphp->addrlen = 3;138     &#125;# 5、安装
# 执行 configure 命令 (默认安装目录 `--prefix=/usr/local/openresty`)# 需要的模块自定义，此处仅示例./configure --prefix=/usr/local/openresty \  --with-luajit \  --with-http_ssl_module \  --with-http_v2_module \  --with-http_realip_module # 执行安装命令makemake install# 6、 开机启动
# 方法一 (/etc/rc.local)：
[root@nginx local]# vim /etc/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/local# 启动 Openresty nginx 服务/usr/local/openresty/nginx/sbin/nginx
PS: Centos7 默认 rc.local 是不可执行的，仅是为了兼容性添加。
若重启验证不生效，则需要给此文件添加执行权限
注意：此文件执行时，  /etc/profile  配置的环境变量不会生效

[root@nginx home]# chmod +x /etc/rc.d/rc.local[root@nginx rc.d]# cd /etc/rc.d/[root@nginx rc.d]# lltotal 4drwxr-xr-x. 2 root root  70 Mar 10 15:30 init.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc0.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc1.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc2.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc3.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc4.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc5.ddrwxr-xr-x. 2 root root  45 Mar 10 15:30 rc6.d-rwxrwxrwx. 1 root root 550 Mar 10 17:36 rc.local[root@nginx rc.d]## 方法二（使用 service）：
在系统服务目录   /usr/lib/systemd/system/  下，创建  openresty.service  文件
[Unit]# 服务描述Description=Openresty# 在 XX 服务后启动After=network.target# 服务运行参数； 注意本节点内命令要用绝对路径[Service]# 后台运行方式Type=forking# 启动命令ExecStart=/usr/local/openresty/nginx/sbin/nginx -c /usr/local/openresty/nginx/conf/nginx.conf# 是否给服务分配独立的临时空间PrivateTmp=true# 运行级别下服务安装的相关设置， 可设置为多用户，即系统运行级别为 3[Install]WantedBy=multi-user.targetsystemctl enable openresty.service    # 设置开机启动systemctl disable openresty.service   # 停止开机启动systemctl start openresty.service     # 启动服务systemctl stop openresty.service      # 停止服务systemctl status openresty.service    # 查看服务状态systemctl restart openresty.service   # 重启服务systemctl list-units --type=service   # 查看所有已启动的服务]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.9_源码安装Redis_5.x</title>
    <url>/2022/08/4b3066d5.html</url>
    <content><![CDATA[# 1、环境及版本
系统版本： Centos 7.9.2009
Redis:  5.0.14
# 2、源码安装 cd redis-5.0.14
tar -zxvf redis-5.0.14.tar.gzcd redis-5.0.14make # 指定 安装目录 PREFIXmake PREFIX=/usr/local/redis install# 指定 安装目录 PREFIX
make PREFIX=/usr/local/redis install
# 3、复制、修改 [redis.conf] 配置
# 创建 redis 下的配置目录mkdir -p /usr/local/redis/confmkdir -p /usr/local/redis/datamkdir -p /usr/local/redis/logs# 创建完成后，目录结构[root@centos7 redis]# tree /usr/local/redis//usr/local/redis/├── bin│     ├── redis-benchmark│     ├── redis-check-aof│     ├── redis-check-rdb│     ├── redis-cli│     ├── redis-sentinel -> redis-server│     └── redis-server├── conf   # 配置文件存放目录|     └── redis.conf   # 从 源码包 复制过来的默认配置文件├── data   # rdb 数据文件存放目录├── logs   # 日志文件存放目录修改 [redis.conf] 配置
[root@centos7 redis]# vim conf/redis.conf# bind IP 配置bind 0.0.0.0# 守护进程方式运行daemonize yes# 日志文件路径（配置到上方创建的日志目录）logfile "/usr/local/redis/log/redis_6379.log"# 数据文件存放目录dir "/usr/local/redis/data"# 4、创建启动脚本方便操作
脚本支持效果如下：

在目录 [/usr/local/redis/] 下创建脚本文件 [ redis.sh ] 内容：
#!/bin/sh# Redis 启动脚本# # @author: hal@xhal.net 2022-08-06# 脚本当前目录SH_DIR=$(cd $( dirname $&#123;BASH_SOURCE[0] &#125; ) &amp;&amp; pwd)APP_NAME="redis-server"# 根路径#APP_PATH=/usr/local/redisAPP_PATH=$SH_DIRBIN_PATH=$APP_PATH/bin# 配置文件路径CONF_PATH=$APP_PATH/confCONF_FILE_PATH=$CONF_PATH/redis.confMASTER_CONF_FILE_PATH=$CONF_PATH/master.confSLAVE_CONF_FILE_PATH=$CONF_PATH/slave.conf# 运行端口 - 默认 6379APP_PORT=6379# Redis 密码 - 默认为空APP_PASS=""## 从配置文件，读取端口、密码CONFIG_STR=$(cat $CONF_FILE_PATH | grep -E '^port|^requirepass')#echo "CONFIG_STR: $CONFIG_STR"PORT_STR=$(echo -e $CONFIG_STR | sed 's/port \([0-9]*\).*/\1/g' )PASS_STR=$(echo -e $CONFIG_STR | sed 's/.*requirepass \(.*\)/\1/g' | sed 's/"//g')#echo "PORT_STR: $PORT_STR"#echo "PASS_STR: $PASS_STR"if [ -n "$PORT_STR" ]; then  APP_PORT=$PORT_STR;fiif [ -n "$PASS_STR" ]; then  APP_PASS=$PASS_STR;fi# 处理密码连接字符串PASS_KEY=""if [ -n "$APP_PASS" ]; then  PASS_KEY="-a $APP_PASS"fiecho -e "\e[35m======================================================================\e[0m"#使用说明 用来提示参数usage()&#123;  echo -e "\e[33mAPP_PATH:\e[0m \e[36m $APP_PATH \e[0m"  echo -e "\e[33mUsage:\e[0m    \e[36m $0 [start|stop|restart] \e[0m"  echo -e "\e[33mUsage:\e[0m    \e[36m $0 [status|running|role|slaveup] \e[0m"  echo -e "\e[33mUsage:\e[0m    \e[36m $0 [tomaster|toslave|startmaster|startslave|startauto] \e[0m"  echo -e "\e[35m----------------------------------------------------------------------\e[0m"  echo -e " -\e[32m start   \e[0m: 正常启动 Redis，$BIN_PATH/redis-server $CONF_FILE_PATH"  echo -e " -\e[32m stop    \e[0m: 停止 Redis, $BIN_PATH/redis-cli shutdown"  echo -e " -\e[32m restart \e[0m: 重启 Redis, stop &amp;&amp; start"  echo -e "\e[35m----------------------------------------------------------------------\e[0m"  echo -e " -\e[32m status  \e[0m: 当前运行状态、对应角色类型"  echo -e " -\e[32m running \e[0m: 当前运行状态，运行中返回 0，否则返回 1"  echo -e " -\e[32m role    \e[0m: 当前运行对应角色类型，master 返回 0， slave 返回 1, 其它 返回2， redis 未运行 返回9"  echo -e " -\e[32m slaveup \e[0m: 当前运行状态为slave时，master_link_status是否为up （是则返回0，否则为1）"  echo -e "\e[35m----------------------------------------------------------------------\e[0m"  echo -e " -\e[32m tomaster   \e[0m: 运行状态转换角色类型为【master】"  echo -e " -\e[32m toslave    \e[0m: 运行状态转换角色类型为【slave】"  echo -e " -\e[32m startmaster\e[0m: 未运行时，以【master】角色类型运行"  echo -e " -\e[32m startslave \e[0m: 未运行时，以【slave】角色类型运行"  echo -e " -\e[32m startauto  \e[0m: 未运行时，根据slave.conf的master节点状态，自动判断当前节点以【master/slave】角色类型运行"  echo ""  exit 1&#125;#检查程序是否已运行is_running()&#123;  # 根据应用名称，获取进程 pid (当存在多个时不适用)  #pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '&#123;print $2&#125;'`  # 根据端口号获取对应 pid  #pid=$(lsof -t -i:$APP_PORT)  pid=$(lsof -i:$APP_PORT | grep *: | awk '&#123;print $2&#125;')  #如果不存在返回 1 存在返回 0  if [ -z "$&#123;pid&#125;" ]; then   return 1  else   return 0  fi&#125;# 启动方法 start()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is already running . pid=$&#123;pid&#125;"  else     $BIN_PATH/redis-server $CONF_FILE_PATH    sleep 1    status    if [ $? -eq "0" ]; then      echo "$APP_NAME - [PORT: $APP_PORT] start success . pid=$&#123;pid&#125;"    else       echo "$APP_NAME - [PORT: $APP_PORT] start fail ."    fi  fi&#125;# 用 master.conf 的配置文件替换 redis.conf 后启动startmaster()&#123;  echo "准备以【 master 】模式启动，复制替换 redis.conf 文件..."  cp -f $MASTER_CONF_FILE_PATH $CONF_FILE_PATH  sleep 1  start  &#125;# 用 slave.conf 的配置文件替换 redis.conf 后启动startslave()&#123;  echo "准备以【 slave 】模式启动，复制替换 redis.conf 文件..."  cp -f $SLAVE_CONF_FILE_PATH $CONF_FILE_PATH  sleep 1  start&#125;# 自动判断当前启用 master 还是 slave 模式startauto()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is already running . pid=$&#123;pid&#125;"    exit 1  fi  # 读取 slave.conf 配置，获取对应 master 配置  arr=(`cat $SLAVE_CONF_FILE_PATH | grep ^replicaof`)  master_host=$&#123;arr[1]&#125;  master_port=$&#123;arr[2]&#125;  authcmd=$(cat $SLAVE_CONF_FILE_PATH | grep ^masterauth | sed 's/masterauth //g' | sed 's/"//g')  auth_key=""    if [ -n "$authcmd" ]; then    auth_key="-a $authcmd"  fi  echo "设置 master -h $master_host -p $master_port $auth_key "  # 判断 master 配置中的服务，对应角色类型  roleName=$($BIN_PATH/redis-cli -h $master_host -p $master_port $auth_key info | grep role: | sed 's/.$//g')    echo "slave 配置的 master 当前类型: $roleName"  if [ "$roleName" = "role:master" ]; then    startslave  else     startmaster  fi&#125;# 停止方法stop()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is running . pid=$&#123;pid&#125; ; stoping..."    # 执行 shutdown    $BIN_PATH/redis-cli $PASS_KEY shutdown      sleep 1    is_running    if [ $? -eq "0" ]; then      echo "$APP_NAME - [PORT: $APP_PORT] stop fail . pid=$&#123;pid&#125;"    else      echo "$APP_NAME - [PORT: $APP_PORT] stop success ."    fi    else     echo "$APP_NAME - [PORT: $APP_PORT] is not running ."  fi&#125;#重启restart()&#123;  stop  start&#125;# 判断运行的角色 [master, slave]# master 返回 0， slave 返回 1, 其它 返回 2， redis 未运行 返回 9role()&#123;  is_running  if [ $? -eq "0" ]; then    roleName=$($BIN_PATH/redis-cli $PASS_KEY info | grep role: | sed 's/.$//g')    if [ "$roleName" = "role:master" ]; then      return 0    elif [ "$roleName" = "role:slave" ]; then      return 1    else      #echo "ERROR: unknow role: [$roleName] !!!"      return 2    fi  else     #echo "$APP_NAME - [PORT: $APP_PORT] is not running ."    return 9  fi&#125;# 判断当前运行的 是否为 slave 且 正常连接上 master# 为简化逻辑，此处实现仅 在 info 信息中匹配 master_link_status:up （运行正常返回 0，否则为 1）# 即正常调用前，应该要知道此节点正常运行 且 为 slaveslaveup()&#123;  linkStatus=$($BIN_PATH/redis-cli $PASS_KEY info | grep master_link_status:up)  if [ -z "$linkStatus" ]; then   #echo "redis master link is down"   return 1  else    #echo "redis master link is up"   return 0  fi&#125;# Change Redis to master; Use Command:  replicaof no one tomaster()&#123;  role  mode=$?  if [ $mode -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] 已经是[ master ] 不必要切换 ."  elif [ $mode -eq "1" ]; then    # 切换配置文件 - 避免下次重启后变化    cp -f $MASTER_CONF_FILE_PATH $CONF_FILE_PATH    # 执行切换为 主服务    $BIN_PATH/redis-cli $PASS_KEY replicaof no one    sleep 1    status  else     echo "$APP_NAME - [PORT: $APP_PORT] 不支持操作状态 [$mode]."  fi&#125;# Change Redis to slave; Use Command:  replicaof masterip masterporttoslave()&#123;  role  mode=$?  if [ $mode -eq "1" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] 已经是[ slave ] 不必要切换 ."  elif [ $mode -eq "0" ]; then    # 切换配置文件 - 避免下次重启后变化    cp -f $SLAVE_CONF_FILE_PATH $CONF_FILE_PATH      authcmd=$(cat $CONF_FILE_PATH | grep ^masterauth | sed 's/"//g')    echo "设置 master 连接密码. $authcmd"    # 执行更新密码    $BIN_PATH/redis-cli $PASS_KEY config set $authcmd    repcmd=$(cat $CONF_FILE_PATH | grep ^replicaof)    echo "准备切换为[ slave ], $repcmd"    # 执行切换为 从服务    $BIN_PATH/redis-cli $PASS_KEY $repcmd      sleep 1    status  else    echo "$APP_NAME - [PORT: $APP_PORT] 不支持操作状态 [$mode]."  fi&#125;# 判断状态status()&#123;  is_running  if [ $? -eq "0" ]; then    echo "$APP_NAME - [PORT: $APP_PORT] is running . pid=$&#123;pid&#125;"    role    if [ $? -eq "0" ]; then      echo "Redis is master role"    elif [ $? -eq "1" ]; then      echo "Redis is slave role"    else       echo "Redis is unknow role"    fi  else     echo "$APP_NAME - [PORT: $APP_PORT] is not running ."  fi&#125;# 根据输入的参数执行对应的方法case "$1" in  "start")    start    ;;  "stop")    stop    ;;  "running")    is_running    ;;  "status")    status    ;;  "role")    role    ;;  "restart")    restart    ;;  "tomaster")    tomaster    ;;  "toslave")    toslave    ;;  "startmaster")    startmaster    ;;  "startslave")    startslave    ;;  "startauto")    startauto    ;;  "slaveup")    slaveup    ;;  *)    usage    ;;esac# 5、配置开机启动服务
在系统服务目录   /usr/lib/systemd/system/  下，创建  redis.service  文件
内容如下：
[Unit]# 服务描述Description=Redis-Server# 在 XX 服务后启动After=network.target# 服务运行参数； 注意本节点内命令要用绝对路径[Service]# 后台运行方式Type=forking# 启动命令ExecStart=/usr/local/redis/redis.sh start# 是否给服务分配独立的临时空间PrivateTmp=true# 运行级别下服务安装的相关设置， 可设置为多用户，即系统运行级别为 3[Install]WantedBy=multi-user.targetsystemctl daemon-reload           # 重载 systemdsystemctl enable redis.service    # 设置开机启动systemctl disable redis.service   # 停止开机启动systemctl start redis.service     # 启动服务systemctl stop redis.service      # 停止服务systemctl status redis.service    # 查看服务状态systemctl restart redis.service   # 重启服务systemctl list-units --type=service   # 查看所有已启动的服务]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx/Openresty日志时间显示到毫秒级的三种方法(不改源码)</title>
    <url>/2022/09/f92ce47.html</url>
    <content><![CDATA[在这里，我们生成三个自定义变量
#以下为内置变量$time_iso8601  日期格式示例： 2022-09-08T18:16:01+08:00$time_local    日期格式示例： 02/Aug/2022:11:11:32 +0800$msec          日期格式示例： 1663839717.105 当前的Unix时间戳,单位为秒，小数为毫秒#生成自定义变量$time_zh    示例值： 2022-10-08 22:00:18$timestamp  示例值： 1663839717105$time_zh_ms 示例值： 2022-10-08 22:00:18,888# 方法一 ：set  （只能在 server 节点内）
建议创建独立 conf 文件，使用 include 方式，如： time-zh.conf   内容如下：
# 该 文件使用方法  在 nginx 配置 server 节点内：   include time-zh.conf;## nginx 内置变量，解析为定义格式，仅支持到秒 （实现支持到毫秒）## $time_iso8601  日期格式示例： 2022-09-08T18:16:01+08:00# $time_local    日期格式示例： 02/Aug/2022:11:11:32 +0800# $msec          日期格式示例： 1663839717.105 当前的 Unix 时间戳，单位为秒，小数为毫秒# 自定义变量 - 默认值#set $time_zh $time_iso8601;#set $timestamp $msec;#set $time_zh_ms $time_zh,000;# 格式化日期if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)(\+\d&#123;2&#125;)") &#123;  set $year   $1;  set $month  $2;  set $day    $3;  set $hour   $4;  set $minute $5;  set $second $6;  # 时区，只到小时  set $time_zone $7;  # 自定义 yyyy-MM-dd hh:mi:ss 格式  set $time_zh "$1-$2-$3 $4:$5:$6";&#125;# 时间戳，单位毫秒  使用 $msec 去除中间的小数点实现if ($msec ~ "^(\d+)\.(\d+)") &#123;  set $timestamp $1$2;  # 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式  set $time_zh_ms $time_zh,$2;&#125;# 方法二： set_by_lua （只能在 server 节点内）
建议创建独立 conf 文件，使用 include 方式，如： time-zh-lua.conf   内容如下：
# 该 文件使用方法  在 nginx 配置 server 节点内：   include time-zh-lua.conf;## nginx 内置变量，解析为定义格式，仅支持到秒 （实现支持到毫秒）## 取 ngx_lua 模块提供的带缓存的时间接口# ngx.now ()          日期格式示例： 1663839717.105  当前的 Unix 时间戳，单位为秒，小数为毫秒；与 nginx 内置变量 $msec 相同#                          -- 因 nginx 有缓存时间，所以与实际服务器时间会有些许偏差，可能偏差几毫秒 - 正常业务可忽略不计#                          -- 若 一定要强一致，可先调用 ngx.update_time () 强制更新，但成本较高，不推荐使用# ngx.time ()         日期格式示例： 1663839717  当前的 Unix 时间戳，单位为秒 (1970 年至今)# ngx.var.time_local 日期格式示例： 02/Aug/2022:11:11:32 +0800# ngx.utctime ()      日期格式示例： 2022-09-08 10:16:01# ngx.localtime ()    日期格式示例： 2022-09-08 18:16:01# ngx.today ()        日期格式示例： 2022-09-08## 本地时间（yyyy-MM-dd hh:mi:ss）set_by_lua $time_zh 'return ngx.localtime()';# Unix 时间戳，单位为毫秒set_by_lua $timestamp 'return ngx.now() * 1000';# 本地时间（yyyy-MM-dd hh:mi:ss,SSS）# 毫秒数： 先用 ngx.now ()%1, 取余数去除秒的部分，再 * 1000 获取毫秒部分，再用 math.floor + 0.5 四舍五入，再用 string.format 固定 3 位长度set_by_lua $time_zh_ms 'return ngx.localtime()..","..string.format("%03d", math.floor(ngx.now()%1*1000+0.5))';# 方法三： map （在 http 节点内）
建议创建独立 conf 文件，使用 include 方式，如： time-zh-map.conf   内容如下：
# 该 文件使用方法  在 nginx 配置 http 节点内：   include time-zh-map.conf;## nginx 内置变量，解析为定义格式，仅支持到秒## $time_iso8601  日期格式示例： 2022-09-08T18:16:01+08:00# $time_local    日期格式示例： 02/Aug/2022:11:11:32 +0800# $msec          日期格式示例： 1663839717.105 当前的 Unix 时间戳，单位为秒，小数为毫秒# 使用以下 map 必须增加 map_hash_bucket_size 大小，否则会报异常# 默认值为 cpu 的缓存行大小，一般为 64map_hash_bucket_size 128;# 自定义 yyyy-MM-dd hh:mi:ss 格式map $time_iso8601 $time_zh &#123;  default $time_iso8601;  "~(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)T(\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;)(\+\d&#123;2&#125;)" "$1 $2";&#125;# 时间戳，单位毫秒  使用 $msec 去除中间的小数点实现map $msec $timestamp &#123;  default $msec;  ~(\d+)\.(\d+) $1$2;&#125;# 自定义 yyyy-MM-dd hh:mi:ss,SSS 带毫秒格式map "$time_iso8601 # $msec" $time_zh_ms &#123;  default $time_zh,000;  "~(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)T(\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;)(\+\d&#123;2&#125;:\d&#123;2&#125;) # (\d+)\.(\d+)$" "$1 $2,$5";&#125;
PS: 若存在多个 Server, 推荐使用方法三，则不需要每个 server 配置一次

]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.9使用yum安装Nginx</title>
    <url>/2022/04/eb7cc45c.html</url>
    <content><![CDATA[# Centos7.9 使用 yum 安装 Nginx
# 
在 CentOS 7.9 上使用 yum 安装 Nginx 非常简单。下面是几个简单步骤：
# 步骤一：更新系统
首先，您需要更新系统以获取最新的软件包和安全修复程序。使用以下命令更新系统：
sudo yum update# 步骤二：安装 nginx
安装 Nginx 非常简单，只需使用以下命令：
sudo yum install nginx然后开始安装过程，等待几分钟，Nginx 将安装在您的系统上。
‍
# 步骤三：启动 nginx 的服务
Nginx 安装完毕后，可以使用以下命令启动 Nginx 服务：
sudo systemctl start nginx启动命令行后，可以使用以下命令检查 Nginx 服务是否正在运行：
sudo systemctl status nginx# 步骤四：配置 Nginx
Nginx 的默认配置文件位于 /etc/nginx/nginx.conf 中。您可以根据需要更改配置文件。在更改配置之后，您需要重新启动 Nginx 服务。使用以下命令重新启动 Nginx 服务：
sudo systemctl restart nginxNginx 安装完毕，您可以尝试使用 Web 服务器上的 IP 地址或域名访问网站。
‍
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux/Centos 环境Shell会话关闭后，本会话启动进程被终止</title>
    <url>/2023/02/37631c5.html</url>
    <content><![CDATA[
原因排查：Linux/Centos 环境 Shell 会话关闭后，本会话启动进程被终止
记录下工作中遇到的问题，希望给遇到的小伙伴参考


原文链接： Linux/Centos 环境 shell 会话关闭后，java 进程被结束
# 一、操作环境、软件版本等信息

Centos 7.9.2009
Java8

# 二、问题场景：

1、 原启动命令  java -jar xxx.jar &gt; test.log 2&gt;&amp;1 &amp;  在  start.sh  脚本文件里
2、有两台一样的服务器， 环境配置都一样； 之前一直是正常的（shell 会话关闭，也可正常运行）
3、其中一台重启后，手动上去执行此脚本启动后；会话关闭进程就没了

# 三、尝试过的解决方法

1、 在命令前增加  nohup  ， 尝试无效
2、 在命令前增加  nohup  ，并使用 exit 退出 shell 会话， 尝试无效
3、 检查设置参数 shopt huponexit huponexit 原本值就为 off, 尝试重新设置后， 一样无效
4、 使用  screen  启动， 尝试无效

# 四、最终排查原因 及 解决方案
# 问题原因：  SSH  版本被更新

没问题的服务器 SSH 版本（旧的）： 7.4p1
有问题的服务器 SSH 版本（新的）： 8.9p1

# 解决方案：
在  ssh@.service  中 [Service] 节点下，添加  KillMode=process  后
使用命令  systemctl restart sshd.service  重启 sshd 服务
参考连接：
https://www.cnblogs.com/byzgss/p/15573344.html
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis7 源码安装</title>
    <url>/2023/01/dacefe23.html</url>
    <content><![CDATA[
源码安装 Redis7, 下载源码、解压、执行安装命令


# 1、下载 Redis 7 源码
可以从 Redis 官网（https://redis.io/download）或者 GitHub 上（https://github.com/redis/redis/releases）下载最新版本的 Redis 源码包，也可以使用以下命令下载最新的稳定版：
wget https://download.redis.io/releases/redis-7.0.0.tar.gz# 2、解压源码包
使用以下命令解压下载的源码包：
tar xzf redis-7.0.0.tar.gz# 3、编译安装
进入解压后的 Redis 目录，执行以下命令编译 Redis：
cd redis-7.0.0make这一步会生成 Redis 的可执行文件，包括 redis-server、redis-cli 等。
# 4、安装 Redis
执行以下命令安装 Redis：
make install这一步会将 Redis 可执行文件复制到 /usr/local/bin 目录下，并将 Redis 配置文件复制到 /etc/redis 目录下。
若需要指定安装目录，则添加 PREFIX  配置
# 指定 安装目录 PREFIXmake PREFIX=/usr/local/redis install# 5、配置 Redis
编辑 /etc/redis/redis.conf 配置文件，修改 Redis 的配置，例如修改监听的端口、设置密码、配置持久化等。
# 6、启动 Redis
执行以下命令启动 Redis：
redis-server /etc/redis/redis.conf如果 Redis 需要认证，还需要在启动 Redis 时指定密码：
redis-server /etc/redis/redis.conf --requirepass your_password# 7、测试 Redis
执行以下命令连接 Redis 并测试：
redis-cli127.0.0.1:6379> pingPONG如果 Redis 返回 PONG，则说明 Redis 已经正常运行。
以上是 Redis 7 源码安装的步骤，需要注意的是，在安装 Redis 时需要根据实际情况修改配置，例如修改监听的端口、设置密码、配置持久化等。同时，在部署 Redis 时，还需要注意安全性和性能等问题，例如限制 Redis 的网络访问权限、优化 Redis 的性能等。
]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis+Keepalived_实现双机主从互备【互为主从、主从自动切换】</title>
    <url>/2022/10/8b778184.html</url>
    <content><![CDATA[
实际生产中，系统压力不大且仅两台物理服务器；实际一个 Redis 服务完全够用，但为了高可用及容灾备份，又不够哨兵模式的三台，所以做此实现方案。

# 1、资源配置：

实际服务器：
192.168.30.7【从】 、 192.168.30.8【主】
(Redis) 虚拟 IP: 192.168.30.6
 系统服务，配置连接此虚拟 IP 即可

# 2、在两台服务器上安装 Redis 安装目录  /usr/local/redis
安装步骤，可参考上篇教程：  Centos7.9 源码安装 Redis 5.x
**【必须用到】** 里面的启动脚本文件  redis.sh
# 3、增加 redis 配置文件  master.conf  /  slave.conf
在目录  /usr/local/redis/conf   下新增
 master.conf  从原  redis.conf  复制，配置文件两台服务器一样就行，如果有配置访问密码一定要一致
slave.conf  配置文件，主要区别如下：
192.168.30.8【主】配置：
# replicaof 配置对方 IP 端口replicaof 192.168.30.7  6379# 访问密码masterauth "xxx123"192.168.30.7【从】配置：
# replicaof 配置对方 IP 端口replicaof 192.168.30.8  6379# 访问密码masterauth "xxx123"配置文件修改完成后，启动服务：
启动 Redis 192.168.30.8【主】 以 【master】 方式启动
[root@centos7 redis]# /usr/local/redis/redis.sh startmaster启动 Redis 192.168.30.7【从】 以 【slave】 方式启动
[root@centos7 redis]# /usr/local/redis/redis.sh startslave# 4、支持 Keepalived 配置脚本文件
于目录  /usr/local/redis/  创建脚本  vip_keepalived.sh  （主从一样）：
#!/bin/sh# 虚拟 IP (Virtual IP) 检测实现 - keepalived 调用实现# # Keepalived vrrp_script 原理:#     根据调用的 script 脚本结果进行分析：#     -  如果执行结果【为 0】， 且 weight 配置的值【大于 0】，则优先级相应的【增加】#     -  如果执行结果【非 0】， 且 weight 配置的值【小于 0】，则优先级相应的【减少】# # 实现原理：   本方案 weight 配置的值 建议【大于 0】, priority 相等、preempt 模式#   1、检测当前节点服务是否正常、若正常且为 master 主节点，则使 vip 为指向本机#   2、若本机节点服务进程不存在（则由从节点判定），以下为从节点判断逻辑#      - 当前节点服务进程是否正常，若正常则判断下 redis 中的 role 是否为 slave#      - 如果是 slave ，判断 master_link_status 是否为 up#      - 如果不为 up, 则代表主节点连接不上，则修改本节点为 master, 则使 vip 为指向本节点##   PS: 本脚本需要配合 redis.sh 使用# @author hal@xhal.net 2022-09-08BASE_PATH=/usr/local/redis# 备份方案，仅检测服务状态 （此方案不能切换为 master）# 0 表示检查进程是否运行# /usr/bin/killall -0 redis-server # 本方案 weight 配置的值 建议【大于 0】, priority 相等、preempt 模式# 1、检测当前节点服务是否正常、若正常且为 master 主节点，返回 0 check()&#123;  # 判断运行的角色 [master, slave] master 返回 0， slave 返回 1, 其它 返回 2， redis 未运行 返回 9  $BASE_PATH/redis.sh role  redisRole=$?  echo "当前 redis role值： [$redisRole]"  if [ $redisRole -eq "0" ]; then    # redis 有运行，且为 master 主节点，返回 0    return 0  elif [ $redisRole -eq "1" ]; then    #echo "redis 有运行，且为 slave 状态"    # 判断 master_link_status 是否为 up    $BASE_PATH/redis.sh slaveup    if [ $? -eq "0" ]; then      #echo "slave 连接 master 正常"       return 1;    else       # slave 连接 master 已断开，修改本节点为 master      $BASE_PATH/redis.sh tomaster      return 0    fi  else    #echo "其它状态，直接返回对应结果 [$redisRole]"    return $redisRole  fi  #echo "redis 未运行，直接返回 1"  return 1&#125;check于目录  /usr/local/redis/  创建脚本  vip_log.sh  （主从一样）：
#!/bin/sh# 记录 Keepalived 切换事件日志# @author hal@xhal.net 2022-09-08now=$(date "+%Y-%m-%d %H:%M:%S")LOG_FILE_PATH=/usr/local/redis/logs/keepalived.logecho "$now -- $1" >> $LOG_FILE_PATH# 5、修改 Keepalived 配置
修改 192.168.30.8【主】 Keepalived 配置  /etc/keepalived/keepalived.conf
[root@centos7 redis]# vim /etc/keepalived/keepalived.conf! Configuration File for keepalived# Redis 相关配置，开始 =======================vrrp_script chk_redis &#123;    script "/usr/local/redis/vip_keepalived.sh "    interval 5 # 检测时间间隔    weight 88  # 如果条件成立的话【script 执行结果为 0】，则权重值按此增加    fall 2     # 定义检测失败的最大次数，如果设置为 3 表示请求失败 2 次时，就认为节点故障    rise 1     # 定义请求成功的次数，如果设置为 1 表示一次请求成功后，就认为节点恢复正常&#125;# 定义虚拟路由，VI_Redis 为虚拟路由的标示符，自己定义名称vrrp_instance VI_Redis &#123;    state BACKUP               # 来决定主从 MASTER BACKUP    interface ens192           # 绑定虚拟 IP 的网络接口，根据自己的机器填写    virtual_router_id 8        # 虚拟路由的 ID 号， 两个节点设置必须一样    mcast_src_ip 192.168.30.8  # 填写本机 ip    priority 100               # 节点优先级，主要比从节点优先级高    preempt                    # 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题    advert_int 1               # 组播信息发送间隔，两个节点设置必须一样，默认 1s    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    # 将 track_script 块加入 instance 配置块    track_script &#123;        chk_redis #执行 Redis 监控的服务    &#125;    # 变为 MASTER 后执行脚本    notify_master "/usr/local/redis/vip_log.sh to_be_【master】"    # 变为 BACKUP 后执行脚本    notify_backup "/usr/local/redis/vip_log.sh to_be_【slave】"    # 状态变为 FAULT 后执行脚本    notify_fault  "/usr/local/redis/vip_log.sh keepalived_is_Fault"    # VRRP 停止 后执行脚本    notify_stop  "/usr/local/redis/vip_log.sh keepalived_is_stop...!"    virtual_ipaddress &#123;        192.168.30.6 #虚拟 ip    &#125;&#125;修改完成后， 重启 keepalived
[root@centos7 redis]# systemctl restart keepalived.service修改 192.168.30.7【从】 Keepalived 配置  /etc/keepalived/keepalived.conf
[root@centos7 redis]# vim /etc/keepalived/keepalived.conf# Redis 相关配置，开始 =======================vrrp_script chk_redis &#123;    script "/usr/local/redis/vip_keepalived.sh "    interval 5 # 检测时间间隔    weight 88  # 如果条件成立的话【script 执行结果为 0】，则权重值按此增加    fall 2     # 定义检测失败的最大次数，如果设置为 3 表示请求失败 2 次时，就认为节点故障    rise 1     # 定义请求成功的次数，如果设置为 1 表示一次请求成功后，就认为节点恢复正常&#125;# 定义虚拟路由，VI_Redis 为虚拟路由的标示符，自己定义名称vrrp_instance VI_Redis &#123;    state BACKUP               # 来决定主从 MASTER BACKUP    interface ens192           # 绑定虚拟 IP 的网络接口，根据自己的机器填写    virtual_router_id 8        # 虚拟路由的 ID 号， 两个节点设置必须一样    mcast_src_ip 192.168.30.7  # 填写本机 ip    priority 100               # 节点优先级，主要比从节点优先级高    preempt                    # 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题    advert_int 1               # 组播信息发送间隔，两个节点设置必须一样，默认 1s    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    # 将 track_script 块加入 instance 配置块    track_script &#123;        chk_redis #执行 Redis 监控的服务    &#125;    # 变为 MASTER 后执行脚本    notify_master "/usr/local/redis/vip_log.sh to_be_【master】"    # 变为 BACKUP 后执行脚本    notify_backup "/usr/local/redis/vip_log.sh to_be_【slave】"    # 状态变为 FAULT 后执行脚本    notify_fault  "/usr/local/redis/vip_log.sh keepalived_is_Fault"    # VRRP 停止 后执行脚本    notify_stop  "/usr/local/redis/vip_log.sh keepalived_is_stop...!"    virtual_ipaddress &#123;        192.168.30.6 #虚拟 ip    &#125;	# 当存在 IP 冲突时，可指定单播 ip 为对方 IP    # unicast_peer &#123;    # 192.168.30.8  # 另一台 IP    #&#125;&#125;修改完成后， 重启 keepalived
[root@centos7 redis]# systemctl restart keepalived.service# 6、修改开机启动  redis.service  配置命令
[Unit]# 服务描述Description=Redis-Server# 在 XX 服务后启动After=network.target# 服务运行参数； 注意本节点内命令要用绝对路径[Service]# 后台运行方式Type=forking# 启动命令 (主要修改此部分由 start 修改为 startauto)ExecStart=/usr/local/redis/redis.sh startauto# 是否给服务分配独立的临时空间PrivateTmp=true# 运行级别下服务安装的相关设置， 可设置为多用户，即系统运行级别为 3[Install]WantedBy=multi-user.target]]></content>
      <categories>
        <category>运维部署</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>何谓立德、立功、立言（三不朽）</title>
    <url>/2022/03/7c550628.html</url>
    <content><![CDATA[
何谓立德、立功、立言（三不朽）


# “立德、立功、立言”：中国古代文人墨客的三大志向
中国文化源远流长，代表着中华民族的文化传统和精神内涵。在众多的传统文化中，文人墨客的文化是一种非常独特和重要的精神文化。在这种文化的背景下，“立德、立功、立言” 被称为文人墨客的 “三大志向”，也被称作 “三不朽” 或 “三绝”。
首先，“立德” 是指一个人要有高尚的道德品质和品行。中国先贤们认为：修身养性，有德者兴，无德者败。在古代，做人首先是要有道德修养，这样才能得到社会的认可和尊重。同时，德行高尚的人往往有良好的人际关系和内在的快乐体验，因此我们也可以从道德修养中找到一种内心的满足和平静。
其次，“立功” 指的是一个人要有卓越的成就和功绩。中国古代文人墨客认为，做人不能只停留在思想和理论层面，而应该付诸实践行动，创造出实际的成就。只有具有卓越成就和功绩的人才能够被后人所记取和传颂，成就卓越的人才能真正摆脱历史的洪流，立于不败之地。
最后，“立言” 是指一个人要有深刻的思想和理论成就，能够留下具有普遍意义、经久不衰的言论或著作。这一点显然是文字创作方面的应用，因为文字可以记录一个时代的思想、文化和价值观。留下的文字能够传承和延续文化精神，经过岁月的沉淀，其价值更能得到世人的确认和认同。
在 “立德、立功、立言” 的旗帜下，中国古代的文人墨客们做出了巨大的贡献。这三个方面被合称为 “三不朽”，意味着一个人只要在其中一个方面成就卓越，就能够成为历史人物，留名后世，永存不朽。这种理念在中国文化传统中一直被强调，也在全球文明史上留下了难以磨灭的印记。在这种精神文化的影响下，中国的文化才得以弥足珍贵，在世界的大舞台上崭露头角。
# 引用百度百科释义 三不朽

作品出处：《左传・襄公二十四年》
创作年代： 春秋时代
原文出处：
二十四年春，穆叔如晋。范宣子逆之，问焉，曰：“古人有言曰：‘死而不朽’，何谓也？” 穆叔未对。
宣子曰：“昔匄之祖，自虞以上为陶唐氏，在夏为御龙氏，在商为豕韦氏，在周为唐杜氏，晋主夏盟为范氏，其是之谓乎？”
穆叔曰：“以豹所闻，此之谓世禄，非不朽也。鲁有先大夫曰臧文仲，既没，其言立，其是之谓乎！
豹闻之，‘太上有立德，其次有立功，其次有立言’，虽久不废，此之谓不朽。若夫保姓受氏，以守宗祊，世不绝祀，无国无之，禄之大者，不可谓不朽。”

]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>古代</tag>
        <tag>名言</tag>
      </tags>
  </entry>
</search>
